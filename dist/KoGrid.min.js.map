{"version":3,"sources":["namespace.js","constants.js","navigation.js","utils.js","aggregateTemplate.html","gridTemplate.html","headerCellTemplate.html","headerRowTemplate.html","rowTemplate.html","kg-cell.js","kg-header-cell.js","kg-header-row.js","kg-mouse-events.js","kg-row.js","ko-grid.js","aggregate.js","column.js","dimension.js","domUtilityService.js","eventProvider.js","grid.js","range.js","row.js","rowFactory.js","searchProvider.js","selectionService.js","sortService.js","styleProvider.js","KoGrid.js"],"names":["window","kg","numberOfGrids","eventStorage","SELECTED_PROP","EXCESS_ROWS","SCROLL_THRESHOLD","ASC","DESC","KG_FIELD","KG_DEPTH","KG_HIDDEN","KG_COLUMN","TEMPLATE_REGEXP","moveSelectionHandler","grid","evt","utils","isNullOrUndefined","config","selectedItems","charCode","which","keyCode","offset","items","renderedRows","index","indexOf","selectionService","lastClickedRow","length","ChangeSelection","$viewport","scrollTop","rowHeight","String","prototype","trim","this","replace","Array","elt","len","from","Number","arguments","Math","ceil","floor","filter","fun","t","Object","TypeError","res","thisp","i","val","call","push","visualLength","node","elem","document","getElementById","createElement","id","style","visibility","body","appendChild","$","css","innerHTML","text","offsetWidth","forIn","obj","action","prop","hasOwnProperty","evalProperty","entity","path","e","ko","unwrapObservable","propPath","split","tempProp","links","endsWith","str","suffix","undefined","getElementsByClassName","cl","retnode","myclass","RegExp","getElementsByTagName","classes","className","test","getTemplatePromise","ajax","newId","seedId","Date","getTime","ieVersion","version","div","iElems","extend","isIe6","isIe7","isIe","aggregateTemplate","defaultCellTemplate","defaultGridTemplate","defaultHeaderCellTemplate","defaultHeaderRowTemplate","defaultRowTemplate","bindingHandlers","init","element","valueAccessor","allBindingsAccessor","viewModel","bindingContext","$userViewModel","$parent","compile","html","cell","applyBindings","cellTemplate","then","p","controlsDescendantBindings","newContext","$grid","headerCell","headerCellTemplate","$data","headerRow","headerRowTemplate","eFuncs","mouseDown","mousedown","source","row","isAggRow","rowTemplate","rowElem","options","gridDim","Dimension","outerHeight","observable","height","outerWidth","width","Grid","gridElem","data","subscribe","$$selectionPhase","searchProvider","evalFilter","refreshDomSizes","isObservable","columnDefs","newDefs","columns","buildColumns","configureColumnWidths","addClass","gridId","toString","append","domUtilityService","AssignGridContainers","eventProvider","EventProvider","each","plugins","onGridInit","BuildStyles","Aggregate","aggEntity","rowFactory","self","offsetTop","label","gLabel","field","gField","depth","gDepth","parent","children","aggChildren","aggIndex","collapsed","offsetLeft","aggLabelFilter","toggleExpand","c","notifyChildren","setExpand","state","child","rowCache","foundMyself","aggCache","agg","renderedChange","aggClass","computed","totalChildren","recurse","cur","x","a","selected","isEven","isOdd","toggleSelected","Column","colDef","delay","clicks","timer","eventTaget","groupIndex","isGroupedBy","groupedByClass","sortable","resizable","minWidth","maxWidth","headerRowHeight","displayName","isAggCol","cellClass","cellFilter","cellFormatter","aggLabelFormatter","_visible","visible","read","write","toggleVisible","enableSort","enableResize","sortDirection","sortingAlgorithm","sortFn","headerClass","getProperty","ret","v","showSortButtonUp","showSortButtonDown","noSortVisible","sort","dir","sortCallback","gripClick","event","stopPropagation","setTimeout","clearTimeout","resizeOnDataCallback","gripOnMouseDown","ctrlKey","columnsChanged","peek","target","parentElement","cursor","startMousePosition","clientX","origWidth","mousemove","onMouseMove","mouseup","gripOnMouseUp","diff","newWidth","off","getWidths","$testContainer","appendTo","ScrollH","clientHeight","ScrollW","clientWidth","empty","attr","LetterW","first","remove","rootEl","$root","$topPanel","find","$groupPanel","$headerContainer","$headerScroller","$headers","$canvas","$footerPanel","UpdateGridLayout","elementDims","rootMaxW","rootMaxH","adjustScrollTop","$style","$styleSheet","cols","visibleColumns","sumWidth","trw","totalRowWidth","scrollH","col","styleSheet","cssText","createTextNode","colToMove","groupToMove","assignEvents","jqueryUIDraggable","droppable","addClasses","drop","onGroupDrop","ready","setDraggables","on","onGroupMouseDown","dragOver","onHeaderMouseDown","onHeaderDrop","enableRowReordering","onRowMouseDown","onRowDrop","preventDefault","draggable","helper","stack","start","navigator","userAgent","bind","dragDrop","groupItem","groupItemScope","dataFor","header","groupName","groupContainer","groupScope","closest","context","configGroups","splice","fixGroupIndexes","groupBy","removeGroup","headerContainer","headerScope","fixColumnIndexes","targetRow","rowScope","rowToMove","scope","prevRow","sd","sortedData","j","assignGridEventHandlers","scroll","scrollLeft","adjustScrollLeft","tabIndex","resize","maintainColumnRatios","defaults","columnWidth","footerRowHeight","footerVisible","displayFooter","canSelectRows","selectAllState","observableArray","displaySelectionCheckbox","selectWithCheckboxOnly","useExternalSorting","sortInfo","multiSelect","enableColumnResize","enableSorting","beforeSelectionChange","afterSelectionChange","jqueryUITheme","keepLastSelected","groups","showGroupPanel","showColumnMenu","showFilter","disableTextSelection","filterOptions","filterText","useExternalFilter","enablePaging","pagingOptions","pageSizes","pageSize","totalServerItems","currentPage","maxCanvasHt","rootDim","lateBindColumns","filteredData","lastSortedColumn","calcMaxCanvasHeight","parsedData","scrollW","rowIndexCellW","rowSelectedCellW","setRenderedRows","newRows","minRowsToRender","viewportH","viewportDimHeight","buildColumnDefsFromData","lateBoundColumns","item","propName","column","sortData","resizeOnData","indx","numOfCols","asterisksArray","percentArray","asteriskNum","totalWidth","isPercent","isNaN","parseInt","temp","noop","remainingWidth","asteriskVal","slice","SelectionService","RowFactory","Initialize","SearchProvider","styleProvider","StyleProvider","sortService","tempArr","filteredDataChanged","isSorting","prevScrollTop","prevScrollIndex","force","rowIndex","UpdateViewableRange","Range","max","longest","arr","kgHeaderText","ngCellText","min","direction","clearSortingData","Sort","$$indexPhase","elementsNeedMeasuring","newCols","footer","showMenu","isVis","nonAggColumns","toggleShowMenu","allSelected","toggleSelectAll","totalFilteredItemsLength","topPanelHeight","headerScrollerDim","maxHeight","vScrollBarIsOpen","newDim","autoFitHeight","maxRows","maxRowsDisplay","selectedItemCount","maxPages","pageForward","page","pageBackward","pageToFirst","pageToLast","cantPageForward","curPage","cantPageBackward","top","bottom","topRow","bottomRow","Row","rowClasses","continueSelection","type","setSelection","rowDisplayIndex","beforeSelectionChangeCallback","afterSelectionChangeCallback","propertyCache","parentCache","dataChanged","rowConfig","numberOfAggregates","groupedData","renderedRange","buildEntityRow","buildAggregateRow","newRange","getGrouping","renderedChangeNoGroups","rowArr","dataArray","dataArr","parseGroupData","g","values","_kg_hidden_","maxDepth","ptr","group","lastSearchStr","searchConditions","extFilter","throttle","filterThrottle","fieldMap","_destroy","condition","pVal","regex","columnDisplay","getRegExp","modifiers","err","buildSearchConditions","qStr","columnFilters","args","columnName","columnValue","toLowerCase","filterTextComputed","multi","selectedIndex","ignoreSelectedItemChanges","rowItem","shiftKey","thisIndx","prevIndx","rows","ri","isSelected","checkAll","selectedlength","colSortFnCache","dateRE","guessSortFn","itemType","dateParts","month","day","sortNumber","sortBool","sortDate","basicSort","match","sortNumberStr","sortDDMMStr","sortMMDDStr","sortAlpha","b","numA","numB","badA","badB","parseFloat","strA","strB","timeA","timeB","dateA","dateB","mtch","m","d","y","unwrappedData","itemA","itemB","propA","propB","canvasStyle","headerScrollerStyle","topPanelStyle","headerStyle","viewportStyle","footerStyle"],"mappings":";CACA,SAAAA,GACA,YAEAA,GAAAC,KACAD,EAAAC,OCJAD,EAAAC,GAAAC,cAAA,EACAF,EAAAC,GAAAE,eAEA,IAAAC,GAAA,kBAGAC,EAAA,EACAC,EAAA,EACAC,EAAA,MACAC,EAAA,OACAC,EAAA,aACAC,EAAA,aCZAC,EAAA,cACAC,EAAA,cACAC,EAAA,MAGAb,GAAAC,GAAAa,qBAAA,SAAAC,EAAAC,GAEA,GAAAhB,EAAAC,GAAAgB,MAAAC,kBAAAH,IAAAf,EAAAC,GAAAgB,MAAAC,kBAAAH,EAAAI,OAAAC,eACA,OAAA,CAEA,IAAAC,GAAAL,EAAAM,OAAAN,EAAAO,QAEAC,EAAA,KAAAH,EAAA,GAAA,KAAAA,EAAA,EAAA,IACA,KAAAG,EACA,OAAA,CAEA,IAAAC,GAAAV,EAAAW,eACAC,EAAAF,EAAAG,QAAAb,EAAAc,iBAAAC,gBAAAN,CACA,OAAA,GAAAG,GAAAA,GAAAF,EAAAM,QACA,GAEAhB,EAAAc,iBAAAG,gBAAAP,EAAAE,GAAAX,GACAW,EAAAF,EAAAM,OAAA1B,EACAU,EAAAkB,UAAAC,UAAAnB,EAAAkB,UAAAC,YAAAnB,EAAAI,OAAAgB,UAAA9B,GACAA,EAAAsB,GACAZ,EAAAkB,UAAAC,UAAAnB,EAAAkB,UAAAC,YAAAnB,EAAAI,OAAAgB,UAAA9B,ICxBA,IAGA+B,OAAAC,UAAAC,OACAF,OAAAC,UAAAC,KAAA,WACA,MAAAC,MAAAC,QAAA,aAAA,MAGAC,MAAAJ,UAAAT,UACAa,MAAAJ,UAAAT,QAAA,SAAAc,GACA,GAAAC,GAAAJ,KAAAR,SAAA,EACAa,EAAAC,OAAAC,UAAA,KAAA,CAKA,KAJAF,EAAA,EAAAA,EAAAG,KAAAC,KAAAJ,GAAAG,KAAAE,MAAAL,GACA,EAAAA,IACAA,GAAAD,GAEAA,EAAAC,EAAAA,IACA,GAAAA,IAAAL,OAAAA,KAAAK,KAAAF,EACA,MAAAE,EAGA,OAAA,KAGAH,MAAAJ,UAAAa,SACAT,MAAAJ,UAAAa,OAAA,SAAAC,GAEA,GAAAC,GAAAC,OAAAd,MACAI,EAAAS,EAAArB,SAAA,CACA,IAAA,kBAAAoB,GACA,KAAA,IAAAG,UAIA,KAAA,GAFAC,MACAC,EAAAV,UAAA,GACAW,EAAA,EAAAd,EAAAc,EAAAA,IACA,GAAAA,IAAAL,GAAA,CACA,GAAAM,GAAAN,EAAAK,EACAN,GAAAQ,KAAAH,EAAAE,EAAAD,EAAAL,IACAG,EAAAK,KAAAF,GAIA,MAAAH,KAGAvD,EAAAC,GAAAgB,OACA4C,aAAA,SAAAC,GACA,GAAAC,GAAAC,SAAAC,eAAA,iBASA,OARAF,KACAA,EAAAC,SAAAE,cAAA,QACAH,EAAAI,GAAA,iBACAJ,EAAAK,MAAAC,WAAA,SACAL,SAAAM,KAAAC,YAAAR,IAEAS,EAAAT,GAAAU,IAAA,OAAAD,EAAAV,GAAAW,IAAA,SACAV,EAAAW,UAAAF,EAAAV,GAAAa,OACAZ,EAAAa,aAEAC,MAAA,SAAAC,EAAAC,GACA,IAAA,GAAAC,KAAAF,GACAA,EAAAG,eAAAD,IACAD,EAAAD,EAAAE,GAAAA,IAIAE,aAAA,SAAAC,EAAAC,GACA,GAAAC,GAAAC,GAAArE,MAAAsE,iBAAAJ,GACAK,EAAAJ,EAAAK,MAAA,KAAAhC,EAAA,EACAiC,EAAAJ,GAAArE,MAAAsE,iBAAAF,EAAAG,EAAA/B,KAAAkC,EAAAH,EAAAzD,MAEA,KADA0B,IACAiC,GAAAC,EAAAlC,GACAiC,EAAAJ,GAAArE,MAAAsE,iBAAAG,EAAAF,EAAA/B,KACAA,GAEA,OAAAiC,IAEAE,SAAA,SAAAC,EAAAC,GACA,MAAAD,IAAAC,GAAA,gBAAAD,GAGA,KAAAA,EAAAjE,QAAAkE,EAAAD,EAAA9D,OAAA+D,EAAA/D,SAFA,GAIAb,kBAAA,SAAA4D,GACA,MAAAiB,UAAAjB,GAAA,OAAAA,GACA,GAEA,GAEAkB,uBAAA,SAAAC,GAIA,IAAA,GAHAC,MACAC,EAAA,GAAAC,QAAA,MAAAH,EAAA,OACAlC,EAAAC,SAAAqC,qBAAA,KACA5C,EAAA,EAAAA,EAAAM,EAAAhC,OAAA0B,IAAA,CACA,GAAA6C,GAAAvC,EAAAN,GAAA8C,SACAJ,GAAAK,KAAAF,IACAJ,EAAAtC,KAAAG,EAAAN,IAGA,MAAAyC,IAEAO,mBAAA,SAAArB,GACA,MAAAZ,GAAAkC,KAAAtB,IAEAuB,MAAA,WACA,GAAAC,IAAA,GAAAC,OAAAC,SACA,OAAA,YACA,MAAAF,IAAA,MAMAG,UAAA,WAGA,IAFA,GAAAC,GAAA,EAAAC,EAAAjD,SAAAE,cAAA,OAAAgD,EAAAD,EAAAZ,qBAAA,KAEAY,EAAAvC,UAAA,oBAAAsC,EAAA,wBACAE,EAAA,KACA,MAAAF,GAAA,EAAAA,EAAAjB,WAIAvB,EAAA2C,OAAAnH,EAAAC,GAAAgB,OACAmG,MAAA,WACA,MAAA,KAAApH,EAAAC,GAAAgB,MAAA8F,aAEAM,MAAA,WACA,MAAA,KAAArH,EAAAC,GAAAgB,MAAA8F,aAEAO,KAAA,WCjIA,MAAAvB,UAAA/F,EAAAC,GAAAgB,MAAA8F,eCAA/G,EAAAC,GAAAsH,kBAAA,WAAA,MAAA,iRCAAvH,EAAAC,GAAAuH,oBAAA,WAAA,MAAA,8GCAAxH,EAAAC,GAAAwH,oBAAA,WAAA,MAAA,yvJCAAzH,EAAAC,GAAAyH,0BAAA,WAAA,MAAA,8jBCAA1H,EAAAC,GAAA0H,yBAAA,WAAA,MAAA,oJAEA3H,EAAAC,GAAA2H,mBAAA,WAAA,MAAA,2QAEAtC,GAAAuC,gBAAA,OAAA,WACA,OACAC,KAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACAA,EAAAC,eAAAD,EAAAE,QAAAD,cACA,IAAAE,GAAA,SAAAC,GACA,GAAAC,GAAAhE,EAAA+D,EACAjD,IAAAmD,cAAAN,EAAAK,EAAA,IACAhE,EAAAuD,GAAAQ,KAAAC,GASA,OAPAN,GAAAQ,aAAAC,KACAT,EAAAQ,aAAAC,KAAA,SAAAC,GACAN,EAAAM,KAGAN,EAAAJ,EAAAQ,eAEAG,4BAAA,QChBAvD,GAAAuC,gBAAA,aAAA,WACA,OACAC,KAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAW,GAAAX,EAAAhB,QAAA4B,MAAAZ,EAAAE,QAAAD,eAAAD,EAAAE,QAAAD,iBACAE,EAAA,SAAAC,GACA,GAAAS,GAAAxE,EAAA+D,EACAjD,IAAAmD,cAAAK,EAAAE,EAAA,IACAxE,EAAAuD,GAAAQ,KAAAS,GCXA,ODaAd,GAAAe,mBAAAN,KACAT,EAAAe,mBAAAN,KAAA,SAAAC,GACAN,EAAAM,KAGAN,EAAAJ,EAAAe,qBClBAJ,4BAAA,QAIAvD,GAAAuC,gBAAA,YAAA,WACA,OACAC,KAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACAA,EAAAC,eAAAD,EAAAe,MAAAd,cACA,IAAAE,GAAA,SAAAC,GACA,GAAAY,GAAA3E,EAAA+D,EACAjD,IAAAmD,cAAAN,EAAAgB,EAAA,IACA3E,EAAAuD,GAAAQ,KAAAY,GCXA,ODaAjB,GAAAkB,kBAAAT,KACAT,EAAAkB,kBAAAT,KAAA,SAAAC,GACAN,EAAAM,KAGAN,EAAAJ,EAAAkB,oBClBAP,4BAAA,QAIAvD,GAAAuC,gBAAA,YAAA,WACA,OACAC,KAAA,SAAAC,EAAAC,GACA,GAAAqB,GAAArB,GACAqB,GAAAC,WACA9E,EAAAuD,GAAAwB,UAAAF,EAAAC,gBCLAhE,GAAAuC,gBAAA,MAAA,WACA,OACAC,KAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACA,GAEAqB,GAFAC,EAAAzB,IACAjH,EAAA0I,EAAAV,MAAAZ,EAAAE,OAGAmB,GADAC,EAAAC,SACA1J,EAAAC,GAAAsH,oBAEAxG,EAAA4I,WAEA,IAAArB,GAAA,SAAAC,GACA,GAAAqB,GAAApF,EAAA+D,EACAkB,GAAArB,eAAAD,EAAAE,QAAAD,eACA9C,GAAAmD,cAAAgB,EAAAG,EAAA,IACApF,EAAAuD,GAAAQ,KAAAqB,GASA,OAPAJ,GAAAb,KACAa,EAAAb,KAAA,SAAAC,GACAN,EAAAM,KAGAN,EAAAkB,IAEAX,4BAAA,QCxBAvD,GAAAuC,gBAAA,OAAA,WACA,OACAC,KAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAA0B,GAAA7B,IACAjE,EAAAS,EAAAuD,EACA8B,GAAAC,QAAA,GAAA9J,GAAAC,GAAA8J,WAAAC,YAAA1E,GAAA2E,WAAAlG,EAAAmG,UAAAC,WAAA7E,GAAA2E,WAAAlG,EAAAqG,UACA,IAAArJ,GAAA,GAAAf,GAAAC,GAAAoK,KAAAR,GACAS,EAAA9F,EAAAxE,EAAAC,GAAAwH,sBCXA,ODaAoC,GAAAU,KAAAC,UAAA,WACAzJ,EAAA0J,mBAGA1J,EAAA2J,eAAAC,aACA5J,EAAA6J,qBAGAtF,GAAAuF,aAAAhB,EAAAiB,aACAjB,EAAAiB,WAAAN,UAAA,SAAAO,GACAhK,EAAAiK,YACAjK,EAAAI,OAAA2J,WAAAC,EACAhK,EAAAkK,eACAlK,EAAAmK,0BAIAnH,EAAAoH,SAAA,UAAAA,SAAApK,EAAAqK,OAAAC,YACAtH,EAAAuH,OAAAhB,GACAvJ,EAAAqH,eAAAD,EAAAe,MACA5D,GAAAmD,cAAA1H,EAAAuJ,EAAA,IAEAtK,EAAAC,GAAAsL,kBAAAC,qBAAAzH,EAAAhD,GACAA,EAAAmK,wBACAnK,EAAA6J,kBAEA7J,EAAA0K,cAAA,GAAAzL,GAAAC,GAAAyL,cAAA3K,GAEAyD,EAAAmH,KAAA5K,EAAAI,OAAAyK,QAAA,SAAAnI,EAAAmF,GACA,kBAAAA,GAAAiD,YACAjD,EAAAiD,WAAA9K,KAGAf,EAAAC,GAAAsL,kBAAAO,YAAA/K,IC9CA8H,4BAAA,QAIA7I,EAAAC,GAAA8L,UAAA,SAAAC,EAAAC,GACA,GAAAC,GAAA3J,IACA2J,GAAAvK,MAAA,EACAuK,EAAAC,UAAA7G,GAAA2E,WAAA,GACAiC,EAAA/G,OAAA6G,EACAE,EAAAE,MAAA9G,GAAA2E,WAAA+B,EAAAK,QACAH,EAAAI,MAAAN,EAAAO,OACAL,EAAAM,MAAAR,EAAAS,OACAP,EAAAQ,OAAAV,EAAAU,OACAR,EAAAS,SAAAX,EAAAW,SACAT,EAAAU,YAAAZ,EAAAY,YACAV,EAAAW,SAAAb,EAAAa,SACAX,EAAAY,UAAAxH,GAAA2E,YAAA,GACAiC,EAAAxC,UAAA,EACAwC,EAAAa,WAAAzH,GAAA2E,YAAA,GAAA+B,EAAAS,QAAApB,WAAA,MACAa,EAAAc,eAAAhB,EAAAgB,eACAd,EAAAe,aAAA,WACA,GAAAC,GAAAhB,EAAAY,WACAZ,GAAAY,WAAAI,GACAhB,EAAAiB,kBAEAjB,EAAAkB,UAAA,SAAAC,GACAnB,EAAAY,UAAAO,GACAnB,EAAAiB,kBAEAjB,EAAAiB,eAAA,WACA3I,EAAAmH,KAAAO,EAAAU,YAAA,SAAAnJ,EAAA6J,GAEA,GADAA,EAAAnI,OAAAxE,GAAAuL,EAAAY,YACAZ,EAAAY,YAAA,CACA,GAAAI,GAAAhB,EAAAY,WACAQ,GAAAF,UAAAF,MAGA1I,EAAAmH,KAAAO,EAAAS,SAAA,SAAAlJ,EAAA6J,GACAA,EAAA3M,GAAAuL,EAAAY,cAEAb,EAAAsB,WACA,IAAAC,IAAA,CACAhJ,GAAAmH,KAAAM,EAAAwB,SAAA,SAAAhK,EAAAiK,GACA,GAAAF,EAAA,CACA,GAAAhM,GAAA,GAAA0K,EAAAS,SAAA5K,OACAmL,EAAAhB,EAAAY,WACAY,GAAAvB,UAAAe,EAAAQ,EAAAvB,YAAA3K,EAAAkM,EAAAvB,YAAA3K,OAEAiC,IAAAyI,EAAAW,WACAW,GAAA,KAIAvB,EAAA0B,kBAEAzB,EAAA0B,SAAAtI,GAAAuI,SAAA,WACA,MAAA3B,GAAAY,YAAA,sBAAA,uBAEAZ,EAAA4B,cAAAxI,GAAAuI,SAAA,WACA,GAAA3B,EAAAU,YAAA7K,OAAA,EAAA,CACA,GAAA0B,GAAA,EACAsK,EAAA,SAAAC,GACAA,EAAApB,YAAA7K,OAAA,EACAyC,EAAAmH,KAAAqC,EAAApB,YAAA,SAAAqB,EAAAC,GACAH,EAAAG,KAGAzK,GAAAuK,EAAArB,SAAA5K,OAIA,OADAgM,GAAA7B,GACAzI,EAEA,MAAAyI,GAAAS,SAAA5K,SAGAmK,EAAAiC,SAAA7I,GAAA2E,YAAA,GACAiC,EAAAkC,OAAA9I,GAAA2E,YAAA,GC7EAiC,EAAAmC,MAAA/I,GAAA2E,YAAA,GACAiC,EAAAoC,eAAA,WAAA,OAAA,IAGAtO,EAAAC,GAAAsO,OAAA,SAAApN,EAAAJ,GACA,GAAAmL,GAAA3J,KACAiM,EAAArN,EAAAqN,OACAC,EAAA,IACAC,EAAA,EACAC,EAAA,IACAzC,GAAA0C,WAAA7I,OACAmG,EAAA9B,MAAAoE,EAAApE,MACA8B,EAAA2C,WAAAvJ,GAAA2E,WAAA,GACAiC,EAAA4C,YAAAxJ,GAAA2E,YAAA,GACAiC,EAAA6C,eAAAzJ,GAAAuI,SAAA,WAAA,MAAA3B,GAAA4C,cAAA,kBAAA,gBACA5C,EAAA8C,SAAA1J,GAAA2E,YAAA,GACAiC,EAAA+C,UAAA3J,GAAA2E,YAAA,GACAiC,EAAAgD,SAAAV,EAAAU,SAAAV,EAAAU,SAAA,GACAhD,EAAAiD,SAAAX,EAAAW,SAAAX,EAAAW,SAAA,IACAjD,EAAAkD,gBAAAjO,EAAAiO,gBACAlD,EAAAmD,YAAA/J,GAAA2E,WAAAuE,EAAAa,aAAAb,EAAAlC,OACAJ,EAAAvK,MAAAR,EAAAQ,MACAuK,EAAAoD,SAAAnO,EAAAmO,SACApD,EAAAqD,UAAAjK,GAAA2E,WAAAuE,EAAAe,WAAA,IACArD,EAAAsD,WAAAhB,EAAAgB,YAAAhB,EAAAiB,cACAvD,EAAAI,MAAAkC,EAAAlC,MACAJ,EAAAc,eAAAwB,EAAAgB,YAAAhB,EAAAiB,eAAAjB,EAAAxB,gBAAAwB,EAAAkB,kBACAxD,EAAAyD,SAAArK,GAAA2E,WAAAjK,EAAAC,GAAAgB,MAAAC,kBAAAsN,EAAAoB,UAAApB,EAAAoB,SACA1D,EAAA0D,QAAAtK,GAAAuI,UACAgC,KAAA,WACA,MAAA3D,GAAAyD,YAEAG,MAAA,SAAApM,GACAwI,EAAA6D,cAAArM,MAGAvC,EAAA6O,YACA9D,EAAA8C,SAAAhP,EAAAC,GAAAgB,MAAAC,kBAAAsN,EAAAQ,WAAAR,EAAAQ,UAEA7N,EAAA8O,cACA/D,EAAA+C,UAAAjP,EAAAC,GAAAgB,MAAAC,kBAAAsN,EAAAS,YAAAT,EAAAS,WAEA/C,EAAAgE,cAAA5K,GAAA2E,WAAAlE,QACAmG,EAAAiE,iBAAA3B,EAAA4B,OACAlE,EAAAmE,YAAA/K,GAAA2E,WAAAuE,EAAA6B,aACAnE,EAAAjD,mBAAAuF,EAAAvF,oBAAAjJ,EAAAC,GAAAyH,4BACAwE,EAAAxD,aAAA8F,EAAA9F,cAAA1I,EAAAC,GAAAuH,sBACAgH,EAAA9F,eAAA7H,EAAA2F,KAAAgI,EAAA9F,gBACAwD,EAAAxD,aAAA1I,EAAAC,GAAAgB,MAAAwF,mBAAA+H,EAAA9F,eAEA8F,EAAAvF,qBAAApI,EAAA2F,KAAAgI,EAAAvF,sBACAiD,EAAAjD,mBAAAjJ,EAAAC,GAAAgB,MAAAwF,mBAAA+H,EAAAvF,qBAEAiD,EAAAoE,YAAA,SAAA7G,GACA,GAAA8G,EAMA,OAJAA,GADArE,EAAAsD,WACAtD,EAAAsD,WAAA/F,EAAA6G,YAAApE,EAAAI,QAEA7C,EAAA6G,YAAApE,EAAAI,QAIAJ,EAAA6D,cAAA,SAAArM,GACA,GAAA8M,EAEAA,GADAxQ,EAAAC,GAAAgB,MAAAC,kBAAAwC,IAAA,gBAAAA,IACAwI,EAAAyD,WAEAjM,EAEAwI,EAAAyD,SAAAa,GACAxQ,EAAAC,GAAAsL,kBAAAO,YAAA/K,IAGAmL,EAAAuE,iBAAAnL,GAAAuI,SAAA,WACA,MAAA3B,GAAA8C,SAAA9C,EAAAgE,kBAAA1P,EAAA0L,EAAA8C,WAEA9C,EAAAwE,mBAAApL,GAAAuI,SAAA,WACA,MAAA3B,GAAA8C,SAAA9C,EAAAgE,kBAAA3P,EAAA2L,EAAA8C,WAEA9C,EAAAyE,cAAArL,GAAAuI,SAAA,WACA,OAAA3B,EAAAgE,kBAEAhE,EAAA0E,KAAA,WACA,IAAA1E,EAAA8C,WACA,OAAA,CAEA,IAAA6B,GAAA3E,EAAAgE,kBAAA3P,EAAAC,EAAAD,CAGA,OAFA2L,GAAAgE,cAAAW,GACA1P,EAAA2P,aAAA5E,EAAA2E,IACA,GAEA3E,EAAA6E,UAAA,SAAAxG,EAAAyG,GACAA,EAAAC,kBACAvC,IACA,IAAAA,EACAC,EAAAuC,WAAA,WAEAxC,EAAA,GACAD,IAEA0C,aAAAxC,GACAxN,EAAAiQ,qBAAAlF,GACAwC,EAAA,IAGAxC,EAAAmF,gBAAA,SAAAL,GAEA,MADAA,GAAAC,kBACAD,EAAAM,SACApF,EAAA6D,gBACA/P,EAAAC,GAAAsL,kBAAAO,YAAA/K,GACAA,EAAAI,OAAAoQ,eAAAxQ,EAAAiK,QAAAwG,SACA,IAEAtF,EAAA0C,WAAAoC,EAAAS,OAAAC,cACAxF,EAAA0C,WAAAxK,MAAAuN,OAAA,aACAzF,EAAA0F,mBAAAZ,EAAAa,QACA3F,EAAA4F,UAAA5F,EAAA9B,MACA5F,EAAAR,UAAA+N,UAAA7F,EAAA8F,aACAxN,EAAAR,UAAAiO,QAAA/F,EAAAgG,gBACA,IAEAhG,EAAA8F,YAAA,SAAAhB,GACAA,EAAAC,iBACA,IAAAkB,GAAAnB,EAAAa,QAAA3F,EAAA0F,mBACAQ,EAAAD,EAAAjG,EAAA4F,SAGA,OAFA5F,GAAA9B,MAAAgI,EAAAlG,EAAAgD,SAAAhD,EAAAgD,SAAAkD,EAAAlG,EAAAiD,SAAAjD,EAAAiD,SAAAiD,EACApS,EAAAC,GAAAsL,kBAAAO,YAAA/K,IACA,GAEAmL,EAAAgG,cAAA,SAAAlB,GChIA,MDiIAA,GAAAC,kBACAzM,EAAAR,UAAAqO,IAAA,aACA7N,EAAAR,UAAAqO,IAAA,WACAnG,EAAA0C,WAAAxK,MAAAuN,OAAAzF,EAAA8C,WAAA,UAAA,UACA9C,EAAA0C,WAAA7I,OCtIAhF,EAAAI,OAAAoQ,eAAAxQ,EAAAiK,QAAAwG,SACA,IAGAxR,EAAAC,GAAA8J,UAAA,SAAAF,GCJAtH,KAAAyH,YAAA,KACAzH,KAAA4H,WAAA,KACA3F,EAAA2C,OAAA5E,KAAAsH,GAEA,IAAAyI,GAAA,WACA,GAAAC,GAAA/N,EAAA,cACA+N,GAAAC,SAAA,QAGAD,EAAArI,OAAA,KAAAE,MAAA,KAAA3F,IAAA,WAAA,YAAAA,IAAA,WAAA,UACA8N,EAAAjH,OAAA,oDACAtL,EAAAC,GAAAsL,kBAAAkH,QAAAF,EAAArI,SAAAqI,EAAA,GAAAG,aACA1S,EAAAC,GAAAsL,kBAAAoH,QAAAJ,EAAAnI,QAAAmI,EAAA,GAAAK,YACAL,EAAAM,QAEAN,EAAAO,KAAA,QAAA,IAEAP,EAAAjH,OAAA,yGACAtL,EAAAC,GAAAsL,kBAAAwH,QAAAR,EAAA5F,WAAAqG,QAAA5I,QACAmI,EAAAU,SAEAjT,GAAAC,GAAAsL,mBACAC,qBAAA,SAAA0H,EAAAnS,GACAA,EAAAoS,MAAA3O,EAAA0O,GAEAnS,EAAAqS,UAAArS,EAAAoS,MAAAE,KAAA,eACAtS,EAAAuS,YAAAvS,EAAAoS,MAAAE,KAAA,iBACAtS,EAAAwS,iBAAAxS,EAAAqS,UAAAC,KAAA,sBACAtS,EAAAyS,gBAAAzS,EAAAqS,UAAAC,KAAA,qBACAtS,EAAA0S,SAAA1S,EAAAyS,gBAAA7G,WAEA5L,EAAAkB,UAAAlB,EAAAoS,MAAAE,KAAA,eAEAtS,EAAA2S,QAAA3S,EAAAkB,UAAAoR,KAAA,aAEAtS,EAAA4S,aAAA5S,EAAAoS,MAAAE,KAAA,kBACArT,EAAAC,GAAAsL,kBAAAqI,iBAAA7S,IAEA6S,iBAAA,SAAA7S,GAEA,GAAAmB,GAAAnB,EAAAkB,UAAAC,WACAnB,GAAA8S,YAAAC,SAAA/S,EAAAoS,MAAA/I,QACArJ,EAAA8S,YAAAE,SAAAhT,EAAAoS,MAAAjJ,SAEAnJ,EAAA6J,kBACA7J,EAAAiT,gBAAA9R,GAAA,IAEA4J,YAAA,SAAA/K,GACA,GAGA0D,GAHAtC,EAAApB,EAAAI,OAAAgB,UACA8R,EAAAlT,EAAAmT,YACA9I,EAAArK,EAAAqK,OAEA+I,EAAApT,EAAAqT,iBACAC,EAAA,CAEAJ,KACAA,EAAAzP,EAAA,IAAA4G,GACA6I,EAAA,KACAA,EAAAzP,EAAA,cAAA4G,EAAA,yCACA6I,EAAAzB,SAAA,UAGAyB,EAAApB,OACA,IAAAyB,GAAAvT,EAAAwT,eACA9P,GAAA,IAAA2G,EAAA,uBAAAkJ,EAAA,SACAlJ,EAAA,oBAAAkJ,EAAA,SACAlJ,EAAA,sBAAAjJ,EAAA,SACAiJ,EAAA,uBAAAkJ,EAAA,SACAlJ,EAAA,yCACAA,EAAA,gCAAAkJ,EAAAtU,EAAAC,GAAAsL,kBAAAiJ,QAAA,GAAA,MACAhQ,EAAAmH,KAAAwI,EAAA,SAAA1Q,EAAAgR,GACAhQ,GAAA,IAAA2G,EAAA,QAAA3H,EAAA,aAAAgR,EAAArK,MAAA,aAAAiK,EAAA,eAAAC,EAAAD,EAAAI,EAAArK,OAAA,eAAAjI,EAAA,QACAiJ,EAAA,SAAA3H,EAAA,aAAAgR,EAAArK,MAAA,QACAiK,GAAAI,EAAArK,QAEApK,EAAAC,GAAAgB,MAAAqG,KACA2M,EAAA,GAAAS,WAAAC,QAAAlQ,EAEAwP,EAAA3I,OAAAtH,SAAA4Q,eAAAnQ,IAEA1D,EAAAmT,YAAAD,GAEAxB,QAAA,GACAE,QAAA,GCnFAI,QAAA,IAEAT,IAEAtS,EAAAC,GAAAyL,cAAA,SAAA3K,GACA,GAAAmL,GAAA3J,IAEA2J,GAAA2I,UAAA9O,OACAmG,EAAA4I,YAAA/O,OACAmG,EAAA6I,aAAA,WAEAhU,EAAAI,OAAA6T,mBACAjU,EAAAuS,YAAA2B,WACAC,YAAA,EACAC,KAAA,SAAAnE,GACA9E,EAAAkJ,YAAApE,MAGAxM,EAAAR,UAAAqR,MAAAnJ,EAAAoJ,iBAEAvU,EAAAuS,YAAAiC,GAAA,YAAArJ,EAAAsJ,kBAAAD,GAAA,WAAArJ,EAAAuJ,UAAAF,GAAA,OAAArJ,EAAAkJ,aACArU,EAAAyS,gBAAA+B,GAAA,YAAArJ,EAAAwJ,mBAAAH,GAAA,WAAArJ,EAAAuJ,UAAAF,GAAA,OAAArJ,EAAAyJ,cACA5U,EAAAI,OAAAyU,qBACA7U,EAAAkB,UAAAsT,GAAA,YAAArJ,EAAA2J,gBAAAN,GAAA,WAAArJ,EAAAuJ,UAAAF,GAAA,OAAArJ,EAAA4J,WAEA5J,EAAAoJ,iBAEAvU,EAAAiK,QAAAR,UAAA0B,EAAAoJ,gBAEApJ,EAAAuJ,SAAA,SAAAzU,GACAA,EAAA+U,kBAIA7J,EAAAoJ,cAAA,WACAvU,EAAAI,OAAA6T,kBAQAjU,EAAAoS,MAAAE,KAAA,uBAAA2C,WACAC,OAAA,QACAzD,SAAA,OACA0D,MAAA,MACAhB,YAAA,EACAiB,MAAA,SAAAnF,GACA9E,EAAAwJ,kBAAA1E,MAEAiE,WACAE,KAAA,SAAAnE,GACA9E,EAAAyJ,aAAA3E,OAjBAjQ,EAAAoS,MAAAE,KAAA,uBAAAP,KAAA,YAAA,QACA,IAAAsD,UAAAC,UAAAzU,QAAA,SAGAb,EAAAoS,MAAAE,KAAA,uBAAAiD,KAAA,cAAA,WAAA,MAAA/T,MAAAgU,YAAA,MAmBArK,EAAAsJ,iBAAA,SAAAxE,GACA,GAAAwF,GAAAhS,EAAAwM,EAAAS,OAEA,IAAA,iBAAA+E,EAAA,GAAAjQ,UAAA,CACA,GAAAkQ,GAAAnR,GAAAoR,QAAAF,EAAA,GACAC,KAEA1V,EAAAI,OAAA6T,mBACAwB,EAAA1D,KAAA,YAAA,QAGA5G,EAAA4I,aAAA6B,OAAAH,EAAAI,UAAAH,EAAA9U,MAAA8U,EAAA5H,aAAA,QAGA3C,GAAA4I,YAAA/O,QAIAmG,EAAAkJ,YAAA,SAAApE,GAEA,GAAA6F,GACAC,CACA5K,GAAA4I,aAEA+B,EAAArS,EAAAwM,EAAAS,QAAAsF,QAAA,mBACA,gBAAAF,EAAAG,QAAAzQ,WACAxF,EAAAkW,aAAAC,OAAAhL,EAAA4I,YAAAnT,MAAA,GACAZ,EAAAkW,aAAArT,KAAAsI,EAAA4I,YAAA8B,aAEAE,EAAAxR,GAAAoR,QAAAG,EAAA,IACAC,GAEA5K,EAAA4I,YAAAnT,OAAAmV,EAAAjI,eAEA9N,EAAAkW,aAAAC,OAAAhL,EAAA4I,YAAAnT,MAAA,GACAZ,EAAAkW,aAAAC,OAAAJ,EAAAjI,aAAA,EAAA3C,EAAA4I,YAAA8B,aAIA1K,EAAA4I,YAAA/O,OACAhF,EAAAoW,oBAEA,IAAApW,EAAAkW,aAAArV,QAAAsK,EAAA2I,UAAAJ,OACAoC,EAAArS,EAAAwM,EAAAS,QAAAsF,QAAA,mBACA,gBAAAF,EAAAG,QAAAzQ,WAAA,2BAAAsQ,EAAAG,QAAAzQ,UACAxF,EAAAqW,QAAAlL,EAAA2I,UAAAJ,MAEAqC,EAAAxR,GAAAoR,QAAAG,EAAA,IACAC,GAEA/V,EAAAsW,YAAAP,EAAAjI,gBAIA3C,EAAA2I,UAAA9O,SAKAmG,EAAAwJ,kBAAA,SAAA1E,GAEA,GAAAsG,GAAA9S,EAAAwM,EAAAS,QAAAsF,QAAA,sBACA,KAAAO,EAAA,GACA,OAAA,CAIA,IAAAC,GAAAjS,GAAAoR,QAAAY,EAAA,GAKA,OAJAC,KAEArL,EAAA2I,WAAA8B,OAAAW,EAAA7C,IAAA8C,KAEA,GAGArL,EAAAyJ,aAAA,SAAA3E,GACA,IAAA9E,EAAA2I,UACA,OAAA,CAGA,IAAAyC,GAAA9S,EAAAwM,EAAAS,QAAAsF,QAAA,sBACA,KAAAO,EAAA,GACA,OAAA,CAGA,IAAAC,GAAAjS,GAAAoR,QAAAY,EAAA,GACA,IAAAC,EAAA,CAEA,GAAArL,EAAA2I,UAAAJ,KAAA8C,EACA,OAAA,CAGA,IAAApD,GAAApT,EAAAiK,QAAAwG,MACA2C,GAAA+C,OAAAhL,EAAA2I,UAAAJ,IAAA9S,MAAA,GACAwS,EAAA+C,OAAAK,EAAA5V,MAAA,EAAAuK,EAAA2I,UAAAJ,KACA1T,EAAAyW,mBACAzW,EAAAiK,QAAAmJ,GAEAnU,EAAAC,GAAAsL,kBAAAO,YAAA/K,GAEAmL,EAAA2I,UAAA9O,OAEA,OAAA,GAIAmG,EAAA2J,eAAA,SAAA7E,GAEA,GAAAyG,GAAAjT,EAAAwM,EAAAS,QAAAsF,QAAA,SACA,IAAAU,EAAA,GAAA,CAIA,GAAAC,GAAApS,GAAAoR,QAAAe,EAAA,GACAC,KAEAD,EAAA3E,KAAA,YAAA,QAEA9S,EAAAC,GAAAE,aAAAwX,WAAAF,UAAAA,EAAAG,MAAAF,MAIAxL,EAAA4J,UAAA,SAAA9E,GAEA,GAAAyG,GAAAjT,EAAAwM,EAAAS,QAAAsF,QAAA,UAEAW,EAAApS,GAAAoR,QAAAe,EAAA,GACA,IAAAC,EAAA,CAEA,GAAAG,GAAA7X,EAAAC,GAAAE,aAAAwX,SACA,IAAAE,EAAAD,OAAAF,EACA,MAGA,IAAAI,GAAA/W,EAAAgX,aACAtU,EAAAqU,EAAAlW,QAAAiW,EAAAD,MAAAzS,QACA6S,EAAAF,EAAAlW,QAAA8V,EAAAvS,OACApE,GAAAgX,WAAAb,OAAAzT,EAAA,GACA1C,EAAAgX,WAAAb,OAAAc,EAAA,EAAAH,EAAAD,MAAAzS,QACApE,EAAA2J,eAAAC,aAEA3K,EAAAC,GAAAE,aAAAwX,UAAA5R,SAIAmG,EAAA+L,wBAAA,WACAlX,EAAAkB,UAAAiW,OAAA,SAAA7S,GACA,GAAA8S,GAAA9S,EAAAoM,OAAA0G,WACAjW,EAAAmD,EAAAoM,OAAAvP,SACAnB,GAAAqX,iBAAAD,GACApX,EAAAiT,gBAAA9R,KAEAnB,EAAAkB,UAAAoQ,IAAA,WACAtR,EAAAkB,UAAAsT,GAAA,UAAA,SAAAlQ,GACA,MAAArF,GAAAC,GAAAa,qBAAAC,EAAAsE,KAOA,KAAAtE,EAAAI,OAAAkX,UACAtX,EAAAkB,UAAA6Q,KAAA,WAAA9S,EAAAC,GAAAC,eACAF,EAAAC,GAAAC,iBAEAa,EAAAkB,UAAA6Q,KAAA,WAAA/R,EAAAI,OAAAkX,UAEA7T,EAAAxE,GAAAsY,OAAA,WACAtY,EAAAC,GAAAsL,kBAAAqI,iBAAA7S,GACAA,EAAAI,OAAAoX,sBACAxX,EAAAmK,2BAIAgB,EAAA+L,0BCxOA/L,EAAA6I,gBAGA/U,EAAAC,GAAAoK,KAAA,SAAAR,GACA,GAAA2O,IACArW,UAAA,GACAsW,YAAA,IACArJ,gBAAA,GACAsJ,gBAAA,GACAC,eAAA,EACAC,cAAA7S,OACA8S,eAAA,EACAC,eAAAxT,GAAA2E,YAAA,GACAM,KAAAjF,GAAAyT,oBACAjO,WAAA/E,OACA3E,cAAAkE,GAAAyT,oBACAC,0BAAA,EACAC,wBAAA,EACAC,oBAAA,EACAC,SAAA7T,GAAA2E,WAAAlE,QACAqT,aAAA,EACAf,SAAA,GACAgB,oBAAA,EACAC,eAAA,EACAf,qBAAAxS,OACAwT,sBAAA,WAAA,OAAA,GACAC,qBAAA,aACAjI,eAAA,aACA5H,YAAA5D,OACAqD,kBAAArD,OACA0T,eAAA,EACAzE,mBAAA,EACApJ,WACA8N,kBAAA,EACAC,UACAC,gBAAA,EACAhE,qBAAA,EACAiE,gBAAA,EACAC,YAAA,EACAC,sBAAA,EACAC,eACAC,WAAA3U,GAAA2E,WAAA,IACAiQ,mBAAA,GAGAC,cAAA,EACAC,eACAC,UAAA/U,GAAAyT,iBAAA,IAAA,IAAA,MACAuB,SAAAhV,GAAA2E,WAAA,KACAsQ,iBAAAjV,GAAA2E,WAAA,GACAuQ,YAAAlV,GAAA2E,WAAA,KAGAiC,EAAA3J,IAEA2J,GAAAuO,YAAAnV,GAAA2E,WAAA,GAEAiC,EAAA/K,OAAAqD,EAAA2C,OAAAqR,EAAA3O,GACAqC,EAAA/K,OAAA2J,WAAAxF,GAAArE,MAAAsE,iBAAAsE,EAAAiB,YACAoB,EAAAd,OAAA,KAAApL,EAAAC,GAAAgB,MAAA0F,QACAuF,EAAAiH,MAAA,KACAjH,EAAAoH,YAAA,KACApH,EAAAkH,UAAA,KACAlH,EAAAqH,iBAAA,KACArH,EAAAsH,gBAAA,KACAtH,EAAAuH,SAAA,KACAvH,EAAAjK,UAAA,KACAiK,EAAAwH,QAAA,KACAxH,EAAAwO,QAAAxO,EAAA/K,OAAA2I,QACAoC,EAAAiN,SAAA7T,GAAAuF,aAAAqB,EAAA/K,OAAAgY,UAAAjN,EAAA/K,OAAAgY,SAAA7T,GAAA2E,WAAAiC,EAAA/K,OAAAgY,UACAjN,EAAA6L,WAAA7L,EAAA/K,OAAAoJ,KACA2B,EAAAyO,iBAAA,EACAzO,EAAA0O,aAAAtV,GAAAyT,oBACA7M,EAAA2O,iBAAA9U,OACAmG,EAAA4N,WAAA5N,EAAA/K,OAAA2Y,WACA5N,EAAA+N,WAAA/N,EAAA/K,OAAA6Y,cAAAC,WACA/N,EAAA6N,qBAAAzU,GAAA2E,WAAAiC,EAAA/K,OAAA4Y,sBACA7N,EAAA4O,oBAAA,WACA,MAAA5O,GAAA+K,eAAAlV,OAAA,EAAAmK,EAAAD,WAAA8O,WAAA7X,OAAA,SAAAmC,GACA,MAAAA,GAAA1E,MAAA,IACAoB,OAAAmK,EAAA/K,OAAAgB,UAAA+J,EAAA0O,eAAA7Y,OAAAmK,EAAA/K,OAAAgB,WAEA+J,EAAA2H,aACAmH,QAAA,EACAxG,QAAA,EACAyG,cAAA,GACAC,iBAAA,GACApH,SAAA,EACAC,SAAA,GAGA7H,EAAAiP,gBAAA,SAAAC,GACAlP,EAAAxK,aAAA0Z,GACAlP,EAAAtB,mBAEAsB,EAAAmP,gBAAA,WACA,GAAAC,GAAApP,EAAAqP,qBAAA,CACA,OAAAxY,MAAAE,MAAAqY,EAAApP,EAAA/K,OAAAgB,YAEA+J,EAAAtB,gBAAA,WACAsB,EAAAwO,QAAAvQ,WAAA+B,EAAA2H,YAAAC,UACA5H,EAAAwO,QAAA1Q,YAAAkC,EAAA2H,YAAAE,UACA7H,EAAAuO,YAAAvO,EAAA4O,wBAEA5O,EAAAsP,wBAAA,WACA,GAAA1D,GAAA5L,EAAA6L,YAIA,IAHA7L,EAAA/K,OAAA2J,aACAoB,EAAA/K,OAAA2J,gBAEAgN,IAAAA,EAAA,GAEA,YADA5L,EAAAuP,kBAAA,EAGA,IAAAC,EACAA,GAAA5D,EAAA,GAEA9X,EAAAC,GAAAgB,MAAA4D,MAAA6W,EAAA,SAAA1W,EAAA2W,GACAA,GAAAvb,GACA8L,EAAA/K,OAAA2J,WAAAlH,MACA0I,MAAAqP,OAKAzP,EAAAjB,aAAA,WACA,GAAAH,GAAAoB,EAAA/K,OAAA2J,WACAqJ,IAEArJ,KACAoB,EAAAsP,0BACA1Q,EAAAoB,EAAA/K,OAAA2J,YAEAoB,EAAA/K,OAAA6X,0BAAA9M,EAAA/K,OAAA0X,eACA/N,EAAAoM,OAAA,EAAA,GACA5K,MAAA,IACAlC,MAAA8B,EAAA2H,YAAAqH,iBACAlM,UAAA,EACAC,WAAA,EACAhG,mBAAA,wHACAP,aAAA,mIAGAoC,EAAA/I,OAAA,IACAyC,EAAAmH,KAAAb,EAAA,SAAArH,EAAA+K,GACA,GAAAoN,GAAA,GAAA5b,GAAAC,GAAAsO,QACAC,OAAAA,EACA7M,MAAA8B,EACA2L,gBAAAlD,EAAA/K,OAAAiO,gBACA0B,aAAA5E,EAAA2P,SACAzK,qBAAAlF,EAAA4P,aACA7L,aAAA/D,EAAA/K,OAAAkY,mBACArJ,WAAA9D,EAAA/K,OAAAmY,eACApN,EACAiI,GAAAvQ,KAAAgY,EACA,IAAAG,GAAA7P,EAAA/K,OAAAwY,OAAA/X,QAAA4M,EAAAlC,MACA,KAAAyP,GACA7P,EAAA+K,aAAAC,OAAA6E,EAAA,EAAAH,KAGA1P,EAAAlB,QAAAmJ,KAGAjI,EAAAhB,sBAAA,WACA,GAAAiJ,GAAAjI,EAAA/K,OAAA2J,WACAkR,EAAA7H,EAAApS,OACAka,KACAC,KACAC,EAAA,EACAC,EAAA,EACApR,EAAAkB,EAAAlB,SAoCA,IAnCAxG,EAAAmH,KAAAwI,EAAA,SAAA1Q,EAAAgR,GACA,GAAA4H,IAAA,EAAAjZ,EAAA2C,MASA,IAPA/F,EAAAC,GAAAgB,MAAAC,kBAAAuT,EAAArK,OACAqK,EAAArK,MAAA,KAEAiS,EAAAC,MAAA7H,EAAArK,OAAApK,EAAAC,GAAAgB,MAAA2E,SAAA6O,EAAArK,MAAA,MAAA,EACAhH,EAAAiZ,EAAA5H,EAAArK,MAAAmS,SAAA9H,EAAArK,MAAA,KAGAkS,MAAAlZ,GAAA,CAGA,GAFAA,EAAAqR,EAAArK,MAEA,QAAAhH,EAAA,CACA4H,EAAAvH,GAAA2G,MAAAY,EAAAvH,GAAAyL,QACA,IAAAsN,GAAAxR,EAAAvH,EAEA,YADAe,GAAAR,UAAAqR,MAAA,WAAAnJ,EAAA4P,aAAAU,GAAA,KAEA,GAAA,IAAApZ,EAAAxB,QAAA,KAIA,MAHAua,IAAA/Y,EAAArB,OACA0S,EAAA9S,MAAA8B,MACAwY,GAAArY,KAAA6Q,EAEA,IAAA4H,EAGA,MAFA5H,GAAA9S,MAAA8B,MACAyY,GAAAtY,KAAA6Q,EAGA,MAAA,2GAGA2H,GAAApR,EAAAvH,GAAA2G,MAAAmS,SAAA9H,EAAArK,MAAA,MAIA6R,EAAAla,OAAA,EAAA,CACAmK,EAAA/K,OAAAoX,wBAAA,EAAA/T,EAAAiY,OAAAvQ,EAAA/K,OAAAoX,sBAAA,CAEA,IAAAmE,GAAAxQ,EAAAwO,QAAAvQ,aAAAiS,EAEAO,EAAA5Z,KAAAE,MAAAyZ,EAAAP,EAEA3X,GAAAmH,KAAAsQ,EAAA,SAAAxY,EAAAgR,GACA,GAAArR,GAAAqR,EAAArK,MAAArI,MAGA,IAFAiJ,EAAAyJ,EAAA9S,OAAAyI,MAAAuS,EAAAvZ,EAEAqR,EAAA9S,MAAA,GAAAqa,EAAA,CACA,GAAAxa,GAAA,CAEA0K,GAAAuO,cAAAvO,EAAAqP,sBAEA/Z,GAAAxB,EAAAC,GAAAsL,kBAAAoH,SAEA3H,EAAAyJ,EAAA9S,OAAAyI,OAAA5I,EAEA4a,GAAApR,EAAAyJ,EAAA9S,OAAAyI,QAIA8R,EAAAna,OAAA,GAEAyC,EAAAmH,KAAAuQ,EAAA,SAAAzY,EAAAgR,GACA,GAAArR,GAAAqR,EAAArK,KACAY,GAAAyJ,EAAA9S,OAAAyI,MAAArH,KAAAE,MAAAiJ,EAAAwO,QAAAvQ,cAAAoS,SAAAnZ,EAAAwZ,MAAA,EAAA,IAAA,IAAA,QAGA1Q,EAAAlB,QAAAA,GACAhL,EAAAC,GAAAsL,kBAAAO,YAAAI,IAEAA,EAAApE,KAAA,WAEAoE,EAAArK,iBAAA,GAAA7B,GAAAC,GAAA4c,iBAAA3Q,GACAA,EAAAD,WAAA,GAAAjM,GAAAC,GAAA6c,WAAA5Q,GACAA,EAAArK,iBAAAkb,WAAA7Q,EAAAD,YACAC,EAAAxB,eAAA,GAAA1K,GAAAC,GAAA+c,eAAA9Q,GACAA,EAAA+Q,cAAA,GAAAjd,GAAAC,GAAAid,cAAAhR,GACAA,EAAAjB,eACAjL,EAAAC,GAAAkd,YAAAnS,QAAAkB,EAAAlB,QACAkB,EAAA+K,aAAAzM,UAAA,SAAA0D,GACA,GAAAA,EAAA,CAGA,GAAAkP,KACA5Y,GAAAmH,KAAAuC,EAAA,SAAAzK,EAAAiY,GACAA,GACA0B,EAAAxZ,KAAA8X,EAAApP,OAAAoP,KAGAxP,EAAA/K,OAAAwY,OAAAyD,EACAlR,EAAAD,WAAAoR,yBAEAnR,EAAA0O,aAAApQ,UAAA,WACA0B,EAAAzB,mBAGAyB,EAAAuO,YAAAvO,EAAA4O,uBACA5O,EAAAoR,WACApR,EAAAhB,2BAGAgB,EAAAuO,YAAAvO,EAAA4O,uBACA5O,EAAAxB,eAAAC,aACAuB,EAAAtB,mBAEAsB,EAAAqR,cAAA,EACArR,EAAAsR,gBAAA,EACAtR,EAAA8H,gBAAA,SAAA9R,EAAAub,GACA,GAAAvR,EAAAqR,gBAAArb,GAAAub,EAAA,CACA,GAAAC,GAAA3a,KAAAE,MAAAf,EAAAgK,EAAA/K,OAAAgB,UAEA+J,GAAAqR,cAAArb,GAAAwb,EAAAxR,EAAAsR,gBAAAld,GAIA4L,EAAAqR,cAAArb,GAAAwb,EAAAxR,EAAAsR,gBAAAld,IAGA4L,EAAAqR,cAAArb,EACAgK,EAAAD,WAAA0R,oBAAA,GAAA3d,GAAAC,GAAA2d,MAAA7a,KAAA8a,IAAA,EAAAH,EAAArd,GAAAqd,EAAAxR,EAAAmP,kBAAAhb,IACA6L,EAAAsR,gBAAAE,KAEAxR,EAAAkM,iBAAA,SAAAD,GACAjM,EAAAqH,kBACArH,EAAAqH,iBAAA4E,WAAAA,IAGAjM,EAAA4P,aAAA,SAAArH,GAEA,GAAAqJ,GAAArJ,EAAAvF,SACA6O,EAAA/d,EAAAC,GAAAgB,MAAA+E,uBAAA,MAAAyO,EAAA9S,MACA6C,GAAAmH,KAAAoS,EAAA,SAAApc,EAAAoC,GACA,GAAAN,EACA,IAAA,IAAA9B,EAAA,CACA,GAAAqc,GAAAxZ,EAAAT,GAAAsP,KAAA,gBACA5P,GAAAzD,EAAAC,GAAAgB,MAAA4C,aAAAma,GAAA,OACA,CACA,GAAAC,GAAAzZ,EAAAT,GAAAsP,KAAA,cACA5P,GAAAzD,EAAAC,GAAAgB,MAAA4C,aAAAoa,GAAA,GAEAxa,EAAAqa,IACAA,EAAAra,KAGAgR,EAAArK,MAAA0T,EAAA/a,KAAAmb,IAAAzJ,EAAAtF,SAAA2O,EAAA,GACA9d,EAAAC,GAAAsL,kBAAAO,YAAAI,IAEAA,EAAA2P,SAAA,SAAApH,EAAA0J,GAEAjS,EAAAoR,WAAA,EACApR,EAAAiN,UACAyC,OAAAnH,EACA0J,UAAAA,IAEAjS,EAAAkS,iBAAA3J,GACAvI,EAAA/K,OAAA+X,mBAGAhN,EAAA/K,OAAAgY,SAAAjN,EAAAiN,SAAA3H,QAFAxR,EAAAC,GAAAkd,YAAAkB,KAAAnS,EAAAiN,SAAA3H,OAAAtF,EAAA6L,YAIA7L,EAAA2O,iBAAApG,EACAvI,EAAAoR,WAAA,GAEApR,EAAAkS,iBAAA,SAAA3J,GACAA,EAIAvI,EAAA2O,kBAAApG,GAAAvI,EAAA2O,kBACA3O,EAAA2O,iBAAA3K,cAAA,IAJA1L,EAAAmH,KAAAO,EAAAlB,UAAA,SAAAvH,EAAAyJ,GACAA,EAAAgD,cAAA,OAMAhE,EAAAsL,iBAAA,WACAtL,EAAAoS,cAAA,CAEA,IAAAnK,GAAAjI,EAAAlB,QAAAwG,MACAhN,GAAAmH,KAAAwI,EAAA,SAAA1Q,EAAAgR,GACAA,EAAA9S,MAAA8B,IAEAyI,EAAAoS,cAAA,GAGApS,EAAAqS,uBAAA,EACArS,EAAAlB,QAAA1F,GAAAyT,oBACA7M,EAAAlB,QAAAR,UAAA,SAAAgU,GACAtS,EAAA/K,OAAAoQ,eAAAiN,KAEAtS,EAAAxK,aAAA4D,GAAAyT,oBACA7M,EAAA/C,UAAA,KACA+C,EAAA/J,UAAA+J,EAAA/K,OAAAgB,UACA+J,EAAAuN,cAAAnU,GAAA2E,WAAAiC,EAAA/K,OAAAsY,eACAvN,EAAAuS,OAAA,KACAvS,EAAA9K,cAAA8K,EAAA/K,OAAAC,cACA8K,EAAAkN,YAAAlN,EAAA/K,OAAAiY,YACAlN,EAAAyM,cAAA3Y,EAAAC,GAAAgB,MAAAC,kBAAAgL,EAAA/K,OAAAyX,eAAA1M,EAAA/K,OAAAwX,cAAAzM,EAAA/K,OAAAyX,cACA1M,EAAA/K,OAAAuX,gBAAAxM,EAAAyM,cAAAzM,EAAA/K,OAAAuX,gBAAA,EACAxM,EAAA2N,eAAA3N,EAAA/K,OAAA0Y,eACA3N,EAAAwS,SAAApZ,GAAA2E,YAAA,GACAiC,EAAA+K,aAAA3R,GAAAyT,oBAGA7M,EAAAiO,aAAAjO,EAAA/K,OAAAgZ,aACAjO,EAAAkO,cAAAlO,EAAA/K,OAAAiZ,cAEAlO,EAAAvC,YAAAuC,EAAA/K,OAAAwI,aAAA3J,EAAAC,GAAA2H,qBACAsE,EAAA9C,kBAAA8C,EAAA/K,OAAAiI,mBAAApJ,EAAAC,GAAA0H,2BACAuE,EAAA/K,OAAAwI,cAAA9I,EAAA2F,KAAA0F,EAAA/K,OAAAwI,eACAuC,EAAAvC,YAAA3J,EAAAC,GAAAgB,MAAAwF,mBAAAyF,EAAA/K,OAAAwI,cAEAuC,EAAA/K,OAAAiI,oBAAAvI,EAAA2F,KAAA0F,EAAA/K,OAAAiI,qBACA8C,EAAA9C,kBAAApJ,EAAAC,GAAAgB,MAAAwF,mBAAAyF,EAAA/K,OAAAiI,oBAGA8C,EAAAkI,eAAA9O,GAAAuI,SAAA,WACA,GAAAsG,GAAAjI,EAAAlB,SACA,OAAAmJ,GAAAjR,OAAA,SAAAuR,GACA,GAAAkK,GAAAlK,EAAA7E,SACA,OAAA+O,OAGAzS,EAAA0S,cAAAtZ,GAAAuI,SAAA,WACA,MAAA3B,GAAAlB,UAAA9H,OAAA,SAAAuR,GACA,OAAAA,EAAAnF,aAGApD,EAAA2S,eAAA,WACA3S,EAAAwS,UAAAxS,EAAAwS,aAEAxS,EAAA4S,YAAA5S,EAAA/K,OAAA2X,eACA5M,EAAA4S,YAAAtU,UAAA,SAAA6C,GACAnB,EAAA/K,OAAAoY,sBAAArN,EAAA6L,WAAAvG,OAAAjP,QACA2J,EAAArK,iBAAAkd,gBAAA1R,GACAnB,EAAA/K,OAAAqY,qBAAAtN,EAAA9K,cAAAoQ,OAAAjP,SAGA2J,EAAA8S,yBAAA1Z,GAAAuI,SAAA,WACA,MAAA3B,GAAA0O,eAAA7Y,SAEAmK,EAAA0N,eAAAtU,GAAAuI,SAAA,WACA,MAAA3B,GAAA/K,OAAAyY,iBAEA1N,EAAA+S,eAAA3Z,GAAA2E,WAAAiC,EAAA/K,OAAAyY,kBAAA,EAAA,EAAA1N,EAAA/K,OAAAiO,gBAAAlD,EAAA/K,OAAAiO,iBACAlD,EAAAqP,kBAAAjW,GAAAuI,SAAA,WACA,MAAA9K,MAAA8a,IAAA,EAAA3R,EAAAwO,QAAA1Q,cAAAkC,EAAA+S,iBAAA/S,EAAA/K,OAAAuX,gBAAA,KAEAxM,EAAAkL,QAAA,SAAA3C,GACA,KAAAvI,EAAA6L,aAAAhW,OAAA,GAAA,CAGA,GAAAga,GAAA7P,EAAA+K,eAAArV,QAAA6S,EACA,KAAAsH,GACAtH,EAAA3F,aAAA,GACA5C,EAAA+K,aAAArT,KAAA6Q,GACAA,EAAA5F,WAAA3C,EAAA+K,eAAAlV,SAEAmK,EAAAmL,YAAA0E,GAEA/b,EAAAC,GAAAsL,kBAAAO,YAAAI,KAEAA,EAAAmL,YAAA,SAAA1V,GACA,GAAA8S,GAAAvI,EAAAlB,UAAA9H,OAAA,SAAAwY,GACA,MAAAA,GAAA7M,cAAAlN,EAAA,IACA,EACA8S,GAAA3F,aAAA,GACA2F,EAAA5F,WAAA,GACA3C,EAAAlB,QAAAkM,OAAAvV,EAAA,GACAuK,EAAA+K,aAAAC,OAAAvV,EAAA,GACAuK,EAAAiL,kBACA,IAAAjL,EAAA+K,eAAAlV,QACAmK,EAAAsL,mBAEAxX,EAAAC,GAAAsL,kBAAAO,YAAAI,IAEAA,EAAAiL,gBAAA,WACA3S,EAAAmH,KAAAO,EAAA+K,eAAA,SAAAxT,EAAAiY,GACAA,EAAA7M,WAAApL,EAAA,MAGAyI,EAAAqI,cAAA,WACA,GAAA6H,GAAA,EACAjI,EAAAjI,EAAAkI,gBAIA,OAHA5P,GAAAmH,KAAAwI,EAAA,SAAA1Q,EAAAgR,GACA2H,GAAA3H,EAAArK,QAEAgS,GAEAlQ,EAAAgT,kBAAA,WACA,GAAA5D,GAAApP,EAAAqP,oBACA4D,EAAAjT,EAAAuO,cACA2E,EAAAD,EAAA7D,EACA+D,EAAA,GAAArf,GAAAC,GAAA8J,SAQA,OANAsV,GAAAC,eAAA,EACAD,EAAAlV,WAAA+B,EAAAqI,gBACA6K,EAAAC,EAAAlV,YAAA+B,EAAA2H,YAAAmH,QACAmE,EAAA7D,GAAApP,EAAA2H,YAAAW,UACA6K,EAAAlV,YAAA+B,EAAA2H,YAAAmH,SAEAqE,GAGAnT,EAAAuN,cAAAvN,EAAA/K,OAAAsY,cACAvN,EAAAqT,QAAAja,GAAA2E,WAAAlH,KAAA8a,IAAA3R,EAAA/K,OAAAiZ,cAAAG,oBAAArO,EAAA6L,aAAAhW,OAAA,IACAmK,EAAAsT,eAAAla,GAAAuI,SAAA,WACA,MAAA3B,GAAAqT,YAEArT,EAAAkN,YAAA9T,GAAA2E,WAAAiC,EAAA/K,OAAA0X,eAAA3M,EAAA/K,OAAAiY,aACAlN,EAAAuT,kBAAAna,GAAAuI,SAAA,WACA,MAAA3B,GAAA9K,gBAAAW,SAEAmK,EAAAwT,SAAApa,GAAAuI,SAAA,WAEA,MADA3B,GAAAqT,QAAAxc,KAAA8a,IAAA3R,EAAA/K,OAAAiZ,cAAAG,oBAAArO,EAAA6L,aAAAhW,OAAA,IACAgB,KAAAC,KAAAkJ,EAAAqT,UAAArT,EAAAkO,cAAAE;GAEApO,EAAAyT,YAAA,WACA,GAAAC,GAAA1T,EAAA/K,OAAAiZ,cAAAI,aACAtO,GAAA/K,OAAAiZ,cAAAI,YAAAzX,KAAAmb,IAAA0B,EAAA,EAAA1T,EAAAwT,cAEAxT,EAAA2T,aAAA,WACA,GAAAD,GAAA1T,EAAA/K,OAAAiZ,cAAAI,aACAtO,GAAA/K,OAAAiZ,cAAAI,YAAAzX,KAAA8a,IAAA+B,EAAA,EAAA,KAEA1T,EAAA4T,YAAA,WACA5T,EAAA/K,OAAAiZ,cAAAI,YAAA,IAEAtO,EAAA6T,WAAA,WACA,GAAAL,GAAAxT,EAAAwT,UACAxT,GAAA/K,OAAAiZ,cAAAI,YAAAkF,IAEAxT,EAAA8T,gBAAA1a,GAAAuI,SAAA,WACA,GAAAoS,GAAA/T,EAAA/K,OAAAiZ,cAAAI,cACAkF,EAAAxT,EAAAwT,UACA,SAAAA,EAAAO,KAEA/T,EAAAgU,iBAAA5a,GAAAuI,SAAA,WACA,GAAAoS,GAAA/T,EAAA/K,OAAAiZ,cAAAI,aACA,SAAAyF,EAAA,KCzfA/T,EAAApE,QCDA7H,GAAA2d,MAAA,SAAAuC,EAAAC,GACA7d,KAAA8d,OAAAF,EACA5d,KAAA+d,UAAAF,GAEApgB,EAAAC,GAAAsgB,IAAA,SAAApb,EAAAhE,EAAAU,GACA,GAAAqK,GAAA3J,IAEA2J,GAAA2M,cAAA1X,EAAA0X,cAEA3M,EAAAsU,WAAArf,EAAAqf,WACAtU,EAAA9K,cAAAD,EAAAC,cACA8K,EAAA/G,OAAAA,EACA+G,EAAArK,iBAAAA,EAEAqK,EAAAiC,SAAA7I,GAAA2E,YAAA,GACAiC,EAAAuU,kBAAA,SAAAzP,GACA9E,EAAArK,iBAAAG,gBAAAkK,EAAA8E,IAEA9E,EAAAoC,eAAA,SAAA7E,EAAAuH,GACA,IAAA9E,EAAA2M,cACA,OAAA,CAEA,IAAA9Q,GAAAiJ,EAAAS,QAAAT,CAKA,OAHA,YAAAjJ,EAAA2Y,MACAxU,EAAAiC,UAAAjC,EAAAiC,YAEAhN,EAAA8X,wBAAA,YAAAlR,EAAA2Y,MACA,EAEAxU,EAAAqN,sBAAArN,EAAA8E,IACA9E,EAAAuU,kBAAAzP,GACA9E,EAAAsN,qBAAAtN,EAAA8E,KAGA,GAGAjL,SAAAmG,EAAA/G,OAAA/E,GACA8L,EAAA/G,OAAA/E,IAAA,EAGA8L,EAAArK,iBAAA8e,aAAAzU,EAAAA,EAAA/G,OAAA/E,IAEA8L,EAAAwR,SAAApY,GAAA2E,WAAA,GACAiC,EAAAC,UAAA7G,GAAA2E,WAAA,OACAiC,EAAA0U,gBAAA,EACA1U,EAAAkC,OAAA9I,GAAAuI,SAAA,WACA,MAAA3B,GAAAwR,WAAA,IAAA,GACA,GAEA,IAEAxR,EAAAmC,MAAA/I,GAAAuI,SAAA,WACA,MAAA3B,GAAAwR,WAAA,IAAA,GACA,GAEA,IAEAxR,EAAAqN,sBAAApY,EAAA0f,8BACA3U,EAAAsN,qBAAArY,EAAA2f,6BACA5U,EAAA6U,iBACA7U,EAAAoE,YAAA,SAAAlL,GC9DA,MAAA8G,GAAA6U,cAAA3b,KAAA8G,EAAA6U,cAAA3b,GAAApF,EAAAC,GAAAgB,MAAAiE,aAAAgH,EAAA/G,OAAAC,MAIApF,EAAAC,GAAA6c,WAAA,SAAA/b,GACA,GAAAmL,GAAA3J,IAEA2J,GAAAqB,YACArB,EAAAuB,YACAvB,EAAA8U,eACA9U,EAAA+U,aAAA,EACA/U,EAAA6O,cACA7O,EAAAgV,aACAhV,EAAArK,iBAAAd,EAAAc,iBACAqK,EAAA/J,UAAA,GACA+J,EAAAiV,mBAAA,EACAjV,EAAAkV,YAAArb,OACAmG,EAAA/J,UAAApB,EAAAI,OAAAgB,UACA+J,EAAAgV,WACArI,cAAA9X,EAAAI,OAAA0X,cACA2H,WAAAzf,EAAAI,OAAAqf,WACApf,cAAAL,EAAAI,OAAAC,cACA6X,uBAAAlY,EAAAI,OAAA8X,uBACA4H,8BAAA9f,EAAAI,OAAAoY,sBACAuH,6BAAA/f,EAAAI,OAAAqY,sBAGAtN,EAAAmV,cAAA,GAAArhB,GAAAC,GAAA2d,MAAA,EAAA7c,EAAAsa,kBAAAhb,GAIA6L,EAAAoV,eAAA,SAAAnc,EAAAuY,GACA,GAAAjU,GAAAyC,EAAAqB,SAAAmQ,EAUA,OATAjU,KAEAA,EAAA,GAAAzJ,GAAAC,GAAAsgB,IAAApb,EAAA+G,EAAAgV,UAAAhV,EAAArK,kBACA4H,EAAAiU,SAAAA,EAAA,GACAjU,EAAA0C,WAAAD,EAAA/J,UAAAub,GAAArS,WAAA,MACA5B,EAAA0E,SAAAhJ,EAAA/E,IAEA8L,EAAAqB,SAAAmQ,GAAAjU,GAEAA,GAGAyC,EAAAqV,kBAAA,SAAAvV,EAAA0R,GACA,GAAAhQ,GAAAxB,EAAAuB,SAAAzB,EAAAa,SAQA,OAPAa,KAEAA,EAAA,GAAA1N,GAAAC,GAAA8L,UAAAC,EAAAE,GACAA,EAAAuB,SAAAzB,EAAAa,UAAAa,GAEAA,EAAA/L,MAAA+b,EAAA,EACAhQ,EAAAvB,WAAAD,EAAA/J,UAAAub,GAAArS,WAAA,MACAqC,GAEAxB,EAAAyR,oBAAA,SAAA6D,GACAtV,EAAAmV,cAAAG,EACAtV,EAAAyB,kBAEAzB,EAAAmR,oBAAA,WAEAtc,EAAA0a,kBAAA1a,EAAA6Z,eAAA7Y,OAAA,IACAhB,EAAAI,OAAA2J,WAAA/E,OACAhF,EAAAkK,eACAlK,EAAA0a,kBAAA,GAEAvP,EAAA+U,aAAA,EACA/U,EAAAqB,YACAxM,EAAAI,OAAAwY,OAAA5X,OAAA,GACAmK,EAAAuV,YAAA1gB,EAAAI,OAAAwY,QAEAzN,EAAAyR,oBAAAzR,EAAAmV,gBAGAnV,EAAAyB,eAAA,WACA,IAAAzB,EAAAkV,aAAArgB,EAAAI,OAAAwY,OAAA5X,OAAA,EAGA,MAFAmK,GAAAwV,6BACA3gB,GAAA6J,iBAGAsB,GAAA8U,cACA,IAAAW,MACAC,EAAA1V,EAAA6O,WAAA7X,OAAA,SAAAmC,GACA,MAAAA,GAAA1E,MAAA,IACAic,MAAA1Q,EAAAmV,cAAAhB,OAAAnU,EAAAmV,cAAAf,UACA9b,GAAAmH,KAAAiW,EAAA,SAAA7F,EAAAL,GACA,GAAAjS,EAEAA,GADAiS,EAAAhS,SACAwC,EAAAqV,kBAAA7F,EAAAxP,EAAAmV,cAAAhB,OAAAtE,GAEA7P,EAAAoV,eAAA5F,EAAAxP,EAAAmV,cAAAhB,OAAAtE,GAGA4F,EAAA/d,KAAA6F,KAEA1I,EAAAoa,gBAAAwG,GACA5gB,EAAA6J,mBAGAsB,EAAAwV,uBAAA,WACA,GAAAC,MACAE,EAAA9gB,EAAA6Z,aAAAgC,MAAA1Q,EAAAmV,cAAAhB,OAAAnU,EAAAmV,cAAAf,UACA9b,GAAAmH,KAAAkW,EAAA,SAAApe,EAAAiY,GACA,GAAAjS,GAAAyC,EAAAoV,eAAA5F,EAAAxP,EAAAmV,cAAAhB,OAAA5c,EAEAke,GAAA/d,KAAA6F,KAEA1I,EAAAoa,gBAAAwG,IAIAzV,EAAA4V,eAAA,SAAAC,GACA,GAAAA,EAAAC,OACAxd,EAAAmH,KAAAoW,EAAAC,OAAA,SAAAve,EAAAiY,GAEAxP,EAAA8U,YAAA9U,EAAA8U,YAAAjf,OAAA,GAAA4K,SAAA/I,KAAA8X,GAEAxP,EAAA6O,WAAAnX,KAAA8X,SAGA,KAAA,GAAA1W,KAAA+c,GAEA,GAAA/c,GAAAvE,GAAAuE,GAAAtE,GAAAsE,GAAApE,GAEAmhB,EAAA9c,eAAAD,GAAA,CAEA,GAAA0I,GAAAxB,EAAAqV,mBACAhV,OAAAwV,EAAAthB,GACA4L,OAAArH,EACAyH,OAAAsV,EAAArhB,GACAgJ,UAAA,EACAuY,aAAA,EACAtV,YACAC,eACAC,SAAAX,EAAAiV,mBACAnU,eAAA+U,EAAAnhB,GAAAoM,gBACA,EACAd,GAAAiV,qBAEAzT,EAAAhB,OAAAR,EAAA8U,YAAAtT,EAAAlB,MAAA,GAEAkB,EAAAhB,SACAgB,EAAAhB,OAAAI,WAAA,GACAY,EAAAhB,OAAAE,YAAAhJ,KAAA8J,IAGAxB,EAAA6O,WAAAnX,KAAA8J,EAAAvI,QAEA+G,EAAA8U,YAAAtT,EAAAlB,OAAAkB,EAEAxB,EAAA4V,eAAAC,EAAA/c,MAMAkH,EAAAuV,YAAA,SAAA9H,GACAzN,EAAAuB,YACAvB,EAAAqB,YACArB,EAAAiV,mBAAA,EACAjV,EAAAkV,cAEA,IAAA7W,GAAAxJ,EAAA6Z,eACAsH,EAAAvI,EAAA5X,OACAoS,EAAApT,EAAAiK,SAEAxG,GAAAmH,KAAApB,EAAA,SAAA9G,EAAAiY,GACAA,EAAA/a,IAAA,CACA,IAAAwhB,GAAAjW,EAAAkV,WACA5c,GAAAmH,KAAAgO,EAAA,SAAAnN,EAAA4V,IACAjO,EAAA3H,GAAA8C,UAAA4S,GAAA1V,IACAzL,EAAAiK,QAAAkM,OAAAwE,EAAAjP,OAAA,EAAA,GAAAzM,GAAAC,GAAAsO,QACAC,QACAlC,MAAA,GACAlC,MAAA,GACA4E,UAAA,EACAC,WAAA,EACAhG,mBAAA,mCAEAqG,UAAA,EACA3N,MAAA+Z,EAAAjP,OACA2C,gBAAArO,EAAAI,OAAAiO,mBAEApP,EAAAC,GAAAsL,kBAAAO,YAAA/K,GAEA,IAAA0T,GAAAN,EAAAjR,OAAA,SAAAgK,GAAA,MAAAA,GAAAZ,OAAA8V,IAAA,GACA1e,EAAA1D,EAAAC,GAAAgB,MAAAiE,aAAAwW,EAAA0G,EACA3N,GAAAjF,aACA9L,EAAA+Q,EAAAjF,WAAA9L,IAEAA,EAAAA,EAAAA,EAAA2H,WAAA,OACA8W,EAAAze,KACAye,EAAAze,OAEAye,EAAA1hB,KACA0hB,EAAA1hB,GAAA2hB,GAEAD,EAAAzhB,KACAyhB,EAAAzhB,GAAA8L,GAEA2V,EAAAvhB,KACAuhB,EAAAvhB,GAAA6T,GAEA0N,EAAAA,EAAAze,KAEAye,EAAAH,SACAG,EAAAH,WAEAG,EAAAH,OAAApe,KAAA8X,KAEA3a,EAAAyW,mBACAtL,EAAA6O,WAAAhZ,OAAA,EACAmK,EAAA4V,eAAA5V,EAAAkV,cAGArgB,EAAAI,OAAAwY,OAAA5X,OAAA,GAAAhB,EAAA6Z,eAAA7Y,OAAA,GCxNAmK,EAAAuV,YAAA1gB,EAAAI,OAAAwY,SAIA3Z,EAAAC,GAAA+c,eAAA,SAAAjc,GACA,GAEAshB,GAFAnW,EAAA3J,KACA+f,IAEApW,GAAAqW,UAAAxhB,EAAAI,OAAA6Y,cAAAE,kBACAhO,EAAA4N,WAAA/Y,EAAAI,OAAA2Y,WACA5N,EAAA+N,WAAAlZ,EAAAI,OAAA6Y,cAAAC,WACA/N,EAAAsW,SAAAzhB,EAAAI,OAAA6Y,cAAAyI,eACAvW,EAAAwW,YACAxW,EAAAvB,WAAA,WAEA5J,EAAA6Z,aADA,IAAA0H,EAAAvgB,OACAhB,EAAAgX,WAAAvG,OAAAtO,OAAA,SAAAwY,GACA,OAAAA,EAAAiH,WAGA5hB,EAAAgX,WAAAvG,OAAAtO,OAAA,SAAAwY,GACA,GAAAA,EAAAiH,SACA,OAAA,CAGA,KAAA,GAAAlf,GAAA,EAAAd,EAAA2f,EAAAvgB,OAAAY,EAAAc,EAAAA,IAAA,CACA,GAAAmf,GAAAN,EAAA7e,EAEA,KAAAmf,EAAAhH,OAAA,CACA,IAAA,GAAA5W,KAAA0W,GACA,GAAAA,EAAAzW,eAAAD,GAAA,CACA,GAAA6d,GAAAvd,GAAArE,MAAAsE,iBAAAmW,EAAA1W,GACA,IAAA6d,GAAAD,EAAAE,MAAAtc,KAAAqc,EAAAxX,YACA,OAAA,EAIA,OAAA,EAGA,GAAAiB,GAAAhH,GAAArE,MAAAsE,iBAAAmW,EAAAkH,EAAAhH,UAAAtW,GAAArE,MAAAsE,iBAAAmW,EAAAxP,EAAAwW,SAAAE,EAAAG,gBACA,KAAAzW,IAAAsW,EAAAE,MAAAtc,KAAA8F,EAAAjB,YACA,OAAA,EAGA,OAAA,KAGAtK,EAAAkL,WAAAoR,sBAEA,IAAA2F,GAAA,SAAAnd,EAAAod,GACA,IACA,MAAA,IAAA7c,QAAAP,EAAAod,GACA,MAAAC,GAEA,MAAA,IAAA9c,QAAAP,EAAArD,QAAA,qDAAA,WAGA2gB,EAAA,SAAAjV,GAEAoU,IACA,IAAAc,EACA,IAAAA,EAAA5e,EAAAlC,KAAA4L,GAAA,CAGA,GAAAmV,GAAAD,EAAA3d,MAAA,IACAjB,GAAAmH,KAAA0X,EAAA,SAAA5f,EAAAP,GACA,GAAAogB,GAAApgB,EAAAuC,MAAA,IACA,IAAA6d,EAAAvhB,OAAA,EAAA,CACA,GAAAwhB,GAAA/e,EAAAlC,KAAAghB,EAAA,IACAE,EAAAhf,EAAAlC,KAAAghB,EAAA,GACAC,IAAAC,GACAlB,EAAA1e,MACAgY,OAAA2H,EACAR,cAAAQ,EAAA/gB,QAAA,OAAA,IAAAihB,cACAX,MAAAE,EAAAQ,EAAA,WAGA,CACA,GAAA9f,GAAAc,EAAAlC,KAAAghB,EAAA,GACA5f,IACA4e,EAAA1e,MACAgY,OAAA,GACAkH,MAAAE,EAAAtf,EAAA,YAOAggB,EAAApe,GAAAuI,SAAA,WACA,GAAAK,GAAAhC,EAAA+N,YACA/N,GAAAqW,WAAArU,GAAAmU,IAEAA,EAAAnU,EACAiV,EAAAjV,GACAhC,EAAAvB,eAGA,iBAAAuB,GAAAsW,UACAkB,EAAAvc,QAAAqb,SAAAtW,EAAAsW,WAEAtW,EAAAqW,WACAxhB,EAAAiK,QAAAR,UAAA,SAAA0D,GACA1J,EAAAmH,KAAAuC,EAAA,SAAAzK,EAAAgR,GACAvI,EAAAwW,SAAAjO,EAAApF,cAAAoU,cAAAjhB,QAAA,OAAA,KAAAiS,EAAAnI,WCpGAtM,EAAAC,GAAA4c,iBAAA,SAAA9b,GACA,GAAAmL,GAAA3J,IACA2J,GAAAyX,MAAA5iB,EAAAI,OAAAiY,YACAlN,EAAA9K,cAAAL,EAAAI,OAAAC,cACA8K,EAAA0X,cAAA7iB,EAAAI,OAAAyiB,cACA1X,EAAApK,eAAAiE,OACAmG,EAAA2X,2BAAA,EAEA3X,EAAAD,cACAC,EAAA6Q,WAAA,SAAA9Q,GACAC,EAAAD,WAAAA,GAIAC,EAAAlK,gBAAA,SAAA8hB,EAAA9iB,GAEA,GADAD,EAAA0J,kBAAA,EACAzJ,GAAAA,EAAA+iB,UAAA7X,EAAAyX,OACA,GAAAzX,EAAApK,eAAA,CACA,GAAAkiB,GAAAjjB,EAAA6Z,aAAAhZ,QAAAkiB,EAAA3e,QACA8e,EAAAljB,EAAA6Z,aAAAhZ,QAAAsK,EAAApK,eAAAqD,OACA,IAAA6e,GAAAC,EACA,OAAA,CAEAA,KACAA,EAAAD,IACAA,GAAAC,EACAA,EAAAD,EAAAC,EACAD,GAAAC,EAGA,KADA,GAAAC,MACAF,GAAAC,EAAAA,IACAC,EAAAtgB,KAAAsI,EAAAD,WAAAsB,SAAA0W,GAaA,OAXAC,GAAAA,EAAAniB,OAAA,GAAAwX,sBAAA2K,EAAAljB,KACAwD,EAAAmH,KAAAuY,EAAA,SAAAzgB,EAAA0gB,GACAA,EAAAhW,UAAA,GACAgW,EAAAhf,OAAA/E,IAAA,EACA,KAAA8L,EAAA9K,cAAAQ,QAAAuiB,EAAAhf,SACA+G,EAAA9K,cAAAwC,KAAAugB,EAAAhf,UAGA+e,EAAAA,EAAAniB,OAAA,GAAAyX,qBAAA0K,EAAAljB,IAEAkL,EAAApK,eAAAoiB,EAAAA,EAAAniB,OAAA,IACA,OAEAmK,GAAAyX,MAMAzX,EAAAyU,aAAAmD,GAAAA,EAAA3V,aALAjC,EAAApK,gBAAAoK,EAAApK,gBAAAgiB,GACA5X,EAAAyU,aAAAzU,EAAApK,gBAAA,GAEAoK,EAAAyU,aAAAmD,EAAA/iB,EAAAI,OAAAuY,kBAAA,GAAAoK,EAAA3V,YAMA,OAFAjC,GAAApK,eAAAgiB,EACA/iB,EAAA0J,kBAAA,GACA,GAIAyB,EAAAyU,aAAA,SAAAmD,EAAAM,GAGA,GAFAN,EAAA3V,SAAAiW,GACAN,EAAA3e,OAAA/E,GAAAgkB,EACAA,EAIA,KAAAlY,EAAA9K,cAAAQ,QAAAkiB,EAAA3e,SACA+G,EAAA9K,cAAAwC,KAAAkgB,EAAA3e,YALA,CACA,GAAA4W,GAAA7P,EAAA9K,cAAAQ,QAAAkiB,EAAA3e,OACA+G,GAAA9K,cAAA8V,OAAA6E,EAAA,KAUA7P,EAAA6S,gBAAA,SAAAsF,GACA,GAAAC,GAAApY,EAAA9K,gBAAAW,MACAuiB,GAAA,GACApY,EAAA9K,cAAA8V,OAAA,EAAAoN,GAEA9f,EAAAmH,KAAA5K,EAAA6Z,eAAA,SAAAnX,EAAAiY,GACAA,EAAAtb,GAAAikB,EACAA,GACAnY,EAAA9K,cAAAwC,KAAA8X,KAGAlX,EAAAmH,KAAAO,EAAAD,WAAAsB,SAAA,SAAA9J,EAAAgG,GACAA,GAAAA,EAAA0E,UACA1E,EAAA0E,SAAAkW,OCxFArkB,EAAAC,GAAAkd,aACAoH,kBACAC,OAAA,8CACAC,YAAA,SAAA/I,GACA,GAAAtL,GACAsU,EACAC,EACAC,EACAC,CAEA,IAAA9e,SAAA2V,GAAA,OAAAA,GAAA,KAAAA,EACA,MAAA,KAIA,QAFAgJ,QAAA,IAGA,IAAA,SACAtU,EAAApQ,EAAAC,GAAAkd,YAAA2H,UACA,MACA,KAAA,UACA1U,EAAApQ,EAAAC,GAAAkd,YAAA4H,QACA,MACA,SACA3U,EAAArK,OAIA,MAAAqK,GACAA,EAGA,kBAAA/M,OAAAhB,UAAAgJ,SAAA1H,KAAA+X,GACA1b,EAAAC,GAAAkd,YAAA6H,SAGA,WAAAN,EACA1kB,EAAAC,GAAAkd,YAAA8H,UAIAvJ,EAAAwJ,MAAA,uBACAllB,EAAAC,GAAAkd,YAAAgI,eAKAR,EAAAjJ,EAAAwJ,MAAAllB,EAAAC,GAAAkd,YAAAqH,QACAG,GAEAC,EAAArI,SAAAoI,EAAA,GAAA,IACAE,EAAAtI,SAAAoI,EAAA,GAAA,IACAC,EAAA,GAEA5kB,EAAAC,GAAAkd,YAAAiI,YACAP,EAAA,GACA7kB,EAAAC,GAAAkd,YAAAkI,YAGArlB,EAAAC,GAAAkd,YAAAkI,aAIArlB,EAAAC,GAAAkd,YAAAmI,YAEAL,UAAA,SAAA/W,EAAAqX,GACA,MAAArX,IAAAqX,EACA,EAEAA,EAAArX,EACA,GAEA,GAEA4W,WAAA,SAAA5W,EAAAqX,GACA,MAAArX,GAAAqX,GAEAJ,cAAA,SAAAjX,EAAAqX,GACA,GAAAC,GACAC,EACAC,GAAA,EACAC,GAAA,CAUA,OATAH,GAAAI,WAAA1X,EAAA1L,QAAA,YAAA,KACA8Z,MAAAkJ,KACAE,GAAA,GAEAD,EAAAG,WAAAL,EAAA/iB,QAAA,YAAA,KACA8Z,MAAAmJ,KACAE,GAAA,GAGAD,GAAAC,EACA,EAEAD,EACA,EAEAC,EACA,GAEAH,EAAAC,GAEAH,UAAA,SAAApX,EAAAqX,GACA,GAAAM,GAAA3X,EAAAuV,cACAqC,EAAAP,EAAA9B,aACA,OAAAoC,IAAAC,EAAA,EAAAA,EAAAD,EAAA,GAAA,GAEAd,SAAA,SAAA7W,EAAAqX,GACA,MAAArX,IAAAqX,EACA,EAEArX,GAAAqX,EAGArX,EAAA,EAAA,GAFA,GAKA8W,SAAA,SAAA9W,EAAAqX,GACA,GAAAQ,GAAA7X,EAAApH,UACAkf,EAAAT,EAAAze,SACA,OAAAif,IAAAC,EAAA,EAAAA,EAAAD,EAAA,GAAA,GAEAX,YAAA,SAAAlX,EAAAqX,GACA,GAAAU,GAAAC,EAAAC,EAAAC,EAAAC,EAAAC,CAuBA,OAtBAH,GAAAjY,EAAAgX,MAAAllB,EAAAC,GAAAkd,YAAAqH,QACA8B,EAAAH,EAAA,GACAC,EAAAD,EAAA,GACAE,EAAAF,EAAA,GACA,GAAAC,EAAArkB,SACAqkB,EAAA,IAAAA,GAEA,GAAAC,EAAAtkB,SACAskB,EAAA,IAAAA,GAEAJ,EAAAK,EAAAF,EAAAC,EACAF,EAAAZ,EAAAL,MAAAllB,EAAAC,GAAAkd,YAAAqH,QACA8B,EAAAH,EAAA,GACAC,EAAAD,EAAA,GACAE,EAAAF,EAAA,GACA,GAAAC,EAAArkB,SACAqkB,EAAA,IAAAA,GAEA,GAAAC,EAAAtkB,SACAskB,EAAA,IAAAA,GAEAH,EAAAI,EAAAF,EAAAC,EACAJ,GAAAC,EACA,EAEAA,EAAAD,EACA,GAEA,GAEAZ,YAAA,SAAAnX,EAAAqX,GACA,GAAAU,GAAAC,EAAAC,EAAAC,EAAAC,EAAAC,CAuBA,OAtBAH,GAAAjY,EAAAgX,MAAAllB,EAAAC,GAAAkd,YAAAqH,QACA8B,EAAAH,EAAA,GACAE,EAAAF,EAAA,GACAC,EAAAD,EAAA,GACA,GAAAC,EAAArkB,SACAqkB,EAAA,IAAAA,GAEA,GAAAC,EAAAtkB,SACAskB,EAAA,IAAAA,GAEAJ,EAAAK,EAAAF,EAAAC,EACAF,EAAAZ,EAAAL,MAAAllB,EAAAC,GAAAkd,YAAAqH,QACA8B,EAAAH,EAAA,GACAE,EAAAF,EAAA,GACAC,EAAAD,EAAA,GACA,GAAAC,EAAArkB,SACAqkB,EAAA,IAAAA,GAEA,GAAAC,EAAAtkB,SACAskB,EAAA,IAAAA,GAEAH,EAAAI,EAAAF,EAAAC,EACAJ,GAAAC,EACA,EAEAA,EAAAD,EACA,GAEA,GAEApK,SAAA,SAAAtR,EAAA4O,GACA,GAAAoN,GAAAhc,GAEA,IAAAgc,GAAApN,EAAA,CAIA,GAEA/I,GACAsL,EAHAjH,EAAA0E,EAAAyC,OACAuC,EAAAhF,EAAAgF,SAIA,IAAAne,EAAAC,GAAAkd,YAAAoH,eAAA9P,EAAAnI,OACA8D,EAAApQ,EAAAC,GAAAkd,YAAAoH,eAAA9P,EAAAnI,WACA,IAAAvG,QAAA0O,EAAAtE,iBACAC,EAAAqE,EAAAtE,iBACAnQ,EAAAC,GAAAkd,YAAAoH,eAAA9P,EAAAnI,OAAAmI,EAAAtE,qBACA,CAEA,GADAuL,EAAA6K,EAAA,IACA7K,EACA,MAEAtL,GAAAnQ,GAAAkd,YAAAsH,YAAA/I,EAAAjH,EAAAnI,QAEA8D,EACApQ,EAAAC,GAAAkd,YAAAoH,eAAA9P,EAAAnI,OAAA8D,EAKAA,EAAApQ,EAAAC,GAAAkd,YAAAmI,UAIAiB,EAAA3V,KAAA,SAAA4V,EAAAC,GACA,GAAAC,GAAA1mB,EAAAC,GAAAgB,MAAAiE,aAAAshB,EAAA/R,EAAAnI,OACAqa,EAAA3mB,EAAAC,GAAAgB,MAAAiE,aAAAuhB,EAAAhS,EAAAnI,MAEA,OAAAqa,IAAAD,EAEAA,EAEAC,EAIAxI,IAAA5d,EACA6P,EAAAsW,EAAAC,GAEA,EAAAvW,EAAAsW,EAAAC,GANA,GAFA,EAFA,IAaApc,EAAAgc,KAEAlI,KAAA,SAAAlF,EAAA5O,GACAvK,EAAAC,GAAAkd,YAAAG,YAGAtd,EAAAC,GAAAkd,YAAAG,WAAA,EACAtd,EAAAC,GAAAkd,YAAAtB,SAAAtR,EAAA4O,GCxPAnZ,EAAAC,GAAAkd,YAAAG,WAAA,KAIAtd,EAAAC,GAAAid,cAAA,SAAAnc,GACAA,EAAA6lB,YAAAthB,GAAAuI,SAAA,WACA,OAAA3D,OAAAnJ,EAAA0Z,cAAApP,WAAA,QAEAtK,EAAA8lB,oBAAAvhB,GAAAuI,SAAA,WACA,OAAA3D,OAAAnJ,EAAAI,OAAAiO,gBAAA,QAEArO,EAAA+lB,cAAAxhB,GAAAuI,SAAA,WACA,OAAAzD,MAAArJ,EAAA2Z,QAAAvQ,aAAA,KAAAD,OAAAnJ,EAAAke,iBAAA,QAEAle,EAAAgmB,YAAAzhB,GAAAuI,SAAA,WACA,OAAAzD,MAAArH,KAAA8a,IAAA,EAAA9c,EAAA2Z,QAAAvQ,aAAAnK,EAAAC,GAAAsL,kBAAAoH,SAAA,KAAAzI,OAAAnJ,EAAAI,OAAAiO,gBAAA,QAEArO,EAAAimB,cAAA1hB,GAAAuI,SAAA,WACA,OAAAzD,MAAArJ,EAAA2Z,QAAAvQ,aAAA,KAAAD,OAAAnJ,EAAAwa,oBAAA,QCgkECxa,EAAKkmB,YAAc3hB,GAAGuI,SAAS,WACxB,OAASzD,MAASrJ,EAAK2Z,QAAQvQ,aAAe,KAAMD,OAAUnJ,EAAKI,OAAOuX,gBAAkB,UAE/F1Y","file":"KoGrid.min.js","sourcesContent":["if (!window.kg) {\n    window.kg = {};\n}\nwindow.kg.numberOfGrids = 0;\nwindow.kg.eventStorage = {};\n","var SELECTED_PROP = '__kg_selected__',\n    GRID_KEY = '__koGrid__',\n    // the # of rows we want to add to the top and bottom of the rendered grid rows\n    EXCESS_ROWS = 8,\n    SCROLL_THRESHOLD = 6,\n    ASC = \"asc\", // constant for sorting direction\n    DESC = \"desc\", // constant for sorting direction\n    KG_FIELD = '_kg_field_',\n    KG_DEPTH = '_kg_depth_',\n    KG_HIDDEN = '_kg_hidden_',\n    KG_COLUMN = '_kg_column_',\n    TEMPLATE_REGEXP = /<.+>/;\n","//set event binding on the grid so we can select using the up/down keys\nwindow.kg.moveSelectionHandler = function(grid, evt) {\n    // null checks\n    if (window.kg.utils.isNullOrUndefined(grid) || window.kg.utils.isNullOrUndefined(grid.config.selectedItems)) {\n        return true;\n    }\n    var charCode = evt.which || evt.keyCode,\n        // detect which direction for arrow keys to navigate the grid\n        offset = (charCode === 38 ? -1 : (charCode === 40 ? 1 : null));\n    if (!offset) {\n        return true;\n    }\n    var items = grid.renderedRows(),\n        index = items.indexOf(grid.selectionService.lastClickedRow) + offset;\n    if (index < 0 || index >= items.length) {\n        return true;\n    }\ngrid.selectionService.ChangeSelection(items[index], evt);\n    if (index > items.length - EXCESS_ROWS) {\n        grid.$viewport.scrollTop(grid.$viewport.scrollTop() + (grid.config.rowHeight * EXCESS_ROWS));\n    } else if (index < EXCESS_ROWS) {\n        grid.$viewport.scrollTop(grid.$viewport.scrollTop() - (grid.config.rowHeight * EXCESS_ROWS));\n    }\n    return false;\n};\n","if (!String.prototype.trim) {\n    String.prototype.trim = function() {\n        return this.replace(/^\\s+|\\s+$/g, '');\n    };\n}\nif (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function(elt /*, from*/) {\n        var len = this.length >>> 0;\n        var from = Number(arguments[1]) || 0;\n        from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n        if (from < 0) {\n            from += len;\n        }\n        for (; from < len; from++) {\n            if (from in this && this[from] === elt) {\n                return from;\n            }\n        }\n        return -1;\n    };\n}\nif (!Array.prototype.filter) {\n    Array.prototype.filter = function(fun /*, thisp */) {\n        \"use strict\";\n        var t = Object(this),\n            len = t.length >>> 0;\n        if (typeof fun !== \"function\") {\n            throw new TypeError();\n        }\n        var res = [];\n        var thisp = arguments[1];\n        for (var i = 0; i < len; i++) {\n            if (i in t) {\n                var val = t[i]; // in case fun mutates this\n                if (fun.call(thisp, val, i, t)) {\n                    res.push(val);\n                }\n            }\n        }\n        return res;\n    };\n}\nwindow.kg.utils = {\n    visualLength: function(node) {\n        var elem = document.getElementById('testDataLength');\n        if (!elem) {\n            elem = document.createElement('SPAN');\n            elem.id = \"testDataLength\";\n            elem.style.visibility = \"hidden\";\n            document.body.appendChild(elem);\n        }\n        $(elem).css('font', $(node).css('font'));\n        elem.innerHTML = $(node).text();\n        return elem.offsetWidth;\n    },\n    forIn: function(obj, action) {\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                action(obj[prop], prop);\n            }\n        }\n    },\n    evalProperty: function(entity, path) {\n        var e = ko.utils.unwrapObservable(entity);\n        var propPath = path.split('.'), i = 0;\n        var tempProp = ko.utils.unwrapObservable(e[propPath[i]]), links = propPath.length;\n        i++;\n        while (tempProp && i < links) {\n            tempProp = ko.utils.unwrapObservable(tempProp[propPath[i]]);\n            i++;\n        }\n        return tempProp;\n    },\n    endsWith: function(str, suffix) {\n        if (!str || !suffix || typeof str != \"string\") {\n            return false;\n        }\n        return str.indexOf(suffix, str.length - suffix.length) !== -1;\n    },\n    isNullOrUndefined: function(obj) {\n        if (obj === undefined || obj === null) {\n            return true;\n        }\n        return false;\n    },\n    getElementsByClassName: function(cl) {\n        var retnode = [];\n        var myclass = new RegExp('\\\\b' + cl + '\\\\b');\n        var elem = document.getElementsByTagName('*');\n        for (var i = 0; i < elem.length; i++) {\n            var classes = elem[i].className;\n            if (myclass.test(classes)) {\n                retnode.push(elem[i]);\n            }\n        }\n        return retnode;\n    },\n    getTemplatePromise: function(path) {\n        return $.ajax(path);\n    },\n    newId: (function() {\n        var seedId = new Date().getTime();\n        return function() {\n            return seedId += 1;\n        };\n    })(),\n\n    // we copy KO's ie detection here bc it isn't exported in the min versions of KO\n    // Detect IE versions for workarounds (uses IE conditionals, not UA string, for robustness)\n    ieVersion: (function() {\n        var version = 3, div = document.createElement('div'), iElems = div.getElementsByTagName('i');\n        // Keep constructing conditional HTML blocks until we hit one that resolves to an empty fragment\n        while (div.innerHTML = '<!--[if gt IE ' + (++version) + ']><i></i><![endif]-->',\n        iElems[0]) ;\n        return version > 4 ? version : undefined;\n    })()\n};\n\n$.extend(window.kg.utils, {\n    isIe6: (function() {\n        return window.kg.utils.ieVersion === 6;\n    })(),\n    isIe7: (function() {\n        return window.kg.utils.ieVersion === 7;\n    })(),\n    isIe: (function() {\n        return window.kg.utils.ieVersion !== undefined;\n    })()\n});\n","window.kg.aggregateTemplate = function() { return '<div data-bind=\"click: toggleExpand, style: {\\'left\\': offsetLeft()}\" class=\"kgAggregate\"><span class=\"kgAggregateText\" data-bind=\"html: $data.label\">(<span data-bind=\"html: totalChildren\"></span> Items)</span><div data-bind=\"attr: {\\'class\\' : aggClass }\"></div></div>'; };\n","window.kg.defaultGridTemplate = function() { return '<div data-bind=\"css: {\\'ui-widget\\': jqueryUITheme, \\'kgNoSelect\\' : disableTextSelection}\"><div class=\"kgTopPanel\" data-bind=\"css: {\\'ui-widget-header\\':jqueryUITheme, \\'ui-corner-top\\': jqueryUITheme}, style: $data.topPanelStyle\"><div class=\"kgGroupPanel\" data-bind=\"visible: $data.showGroupPanel, style: headerStyle\"><div class=\"kgGroupPanelDescription\" data-bind=\"visible: configGroups().length == 0\">Drag a column header here and drop it to group by that column</div><ul data-bind=\"visible: configGroups().length > 0, foreach: configGroups\" class=\"kgGroupList\"><li class=\"kgGroupItem\"><span class=\"kgGroupElement\"><div class=\"kgGroupName\"><span data-bind=\"text: displayName\"></span> <span data-bind=\"click: function(data) { $root.removeGroup($index()) }\" class=\"kgRemoveGroup\">x</span></div><span data-bind=\"visible: $index() < ($root.configGroups().length - 1)\" class=\"kgGroupArrow\"></span></span></li></ul></div><div class=\"kgHeaderContainer\" data-bind=\"style: headerStyle\"><div class=\"kgHeaderScroller\" data-bind=\"style: headerScrollerStyle, kgHeaderRow: $data\"></div></div><div class=\"kgHeaderButton\" data-bind=\"visible: ($data.showColumnMenu || $data.showFilter), click: toggleShowMenu\"><div class=\"kgHeaderButtonArrow\"></div></div><div data-bind=\"visible: showMenu\" class=\"kgColMenu\"><div data-bind=\"visible: showFilter\"><input placeholder=\"Search Field:Value\" type=\"text\" data-bind=\"value: filterText, valueUpdate: \\'afterkeydown\\'\"></div><div data-bind=\"visible: showColumnMenu\"><span class=\"kgMenuText\">Choose Columns:</span><ul class=\"kgColList\" data-bind=\"foreach: nonAggColumns\"><li class=\"kgColListItem\"><label style=\"position: relative\"><input type=\"checkbox\" class=\"kgColListCheckbox\" data-bind=\"checked: visible\"> <span data-bind=\"text: displayName, click: toggleVisible\"></span> <a title=\"Group By\" data-bind=\"attr: {\\'class\\': groupedByClass }, visible: (field != \\'\\\\u2714\\'), click: $parent.groupBy\"></a> <span class=\"kgGroupingNumber\" data-bind=\"visible: groupIndex() > 0, text: groupIndex\"></span></label></li></ul></div></div></div><div class=\"kgViewport\" data-bind=\"css: {\\'ui-widget-content\\': jqueryUITheme}, style: viewportStyle\"><div class=\"kgCanvas\" data-bind=\"style: canvasStyle\"><div data-bind=\"foreach: renderedRows\" style=\"position: absolute\"><div data-bind=\"style: { \\'top\\': offsetTop, \\'height\\': $parent.rowHeight + \\'px\\' }, click: toggleSelected, css: {\\'selected\\': selected, \\'even\\': isEven , \\'odd\\': isOdd, \\'ui-state-default\\': $parent.jqueryUITheme && isOdd, \\'ui-state-active\\':$parent.jqueryUITheme && isEven}, kgRow: $data\" class=\"kgRow\"></div></div></div></div><div class=\"kgFooterPanel\" data-bind=\"css: {\\'ui-widget-content\\': jqueryUITheme, \\'ui-corner-bottom\\': jqueryUITheme}, style: footerStyle\"><div class=\"kgTotalSelectContainer\" data-bind=\"visible: footerVisible\"><div class=\"kgFooterTotalItems\" data-bind=\"css: {\\'kgNoMultiSelect\\': !multiSelect}\"><span class=\"kgLabel\">Total Items: <span data-bind=\"text: maxRowsDisplay\"></span></span><span data-bind=\"visible: filterText().length > 0\" class=\"kgLabel\">(Showing: <span data-bind=\"text: totalFilteredItemsLength\"></span>)</span></div><div class=\"kgFooterSelectedItems\" data-bind=\"visible: multiSelect\"><span class=\"kgLabel\">Selected Items: <span data-bind=\"text: selectedItemCount\"></span></span></div></div><div class=\"kgPagerContainer\" style=\"float: right; margin-top: 10px\" data-bind=\"visible: (footerVisible && enablePaging), css: {\\'kgNoMultiSelect\\': !multiSelect}\"><div style=\"float:left; margin-right: 10px\" class=\"kgRowCountPicker\"><span style=\"float: left; margin-top: 3px\" class=\"kgLabel\">Page Size:</span><select style=\"float: left;height: 27px; width: 100px\" data-bind=\"value: pagingOptions.pageSize, options: pagingOptions.pageSizes\"></select></div><div style=\"float:left; margin-right: 10px; line-height:25px\" class=\"kgPagerControl\" style=\"float: left; min-width: 135px\"><button class=\"kgPagerButton\" data-bind=\"click: pageToFirst, disable: cantPageBackward()\" title=\"First Page\"><div class=\"kgPagerFirstTriangle\"><div class=\"kgPagerFirstBar\"></div></div></button> <button class=\"kgPagerButton\" data-bind=\"click: pageBackward, disable: cantPageBackward()\" title=\"Previous Page\"><div class=\"kgPagerFirstTriangle kgPagerPrevTriangle\"></div></button> <input class=\"kgPagerCurrent\" type=\"number\" style=\"width:50px; height: 24px; margin-top: 1px; padding: 0px 4px\" data-bind=\"value: pagingOptions.currentPage, valueUpdate: \\'afterkeydown\\'\"> <button class=\"kgPagerButton\" data-bind=\"click: pageForward, disable: cantPageForward()\" title=\"Next Page\"><div class=\"kgPagerLastTriangle kgPagerNextTriangle\"></div></button> <button class=\"kgPagerButton\" data-bind=\"click: pageToLast, disable: cantPageForward()\" title=\"Last Page\"><div class=\"kgPagerLastTriangle\"><div class=\"kgPagerLastBar\"></div></div></button></div></div></div></div>'; };\n","window.kg.defaultHeaderCellTemplate = function() { return '<div data-bind=\"style: { cursor : sortable() ? \\'pointer\\' : \\'default\\' }, click: sort, css: {\\'kgSorted\\': !noSortVisible }, attr: {\\'class\\': \\'kgHeaderSortColumn \\' + headerClass()}\"><div data-bind=\"attr: { \\'class\\': \\'colt\\' + $index() + \\' kgHeaderText\\' }, html: displayName\"></div><div class=\"kgSortButtonDown\" data-bind=\"visible: showSortButtonDown\"></div><div class=\"kgSortButtonUp\" data-bind=\"visible: showSortButtonUp\"></div><div data-bind=\"visible: resizable, click: gripClick, mouseEvents: { mouseDown: gripOnMouseDown }\" class=\"kgHeaderGrip\"></div></div>'; };\n","window.kg.defaultHeaderRowTemplate = function() { return '<div data-bind=\"foreach: visibleColumns\"><div data-bind=\"kgHeaderCell: $data, attr: { \\'class\\': \\'kgHeaderCell col\\' + $index() }\"></div></div>'; };\n","window.kg.defaultRowTemplate = function() { return '<div data-bind=\"style: { cursor : canSelectRows ? \\'pointer\\' : \\'default\\' }, foreach: $grid.visibleColumns, css: { \\'ui-widget-content\\': $grid.jqueryUITheme }\"><div data-bind=\"attr: { \\'class\\': cellClass() + \\' kgCell col\\' + $index() }, kgCell: $data\"></div></div>'; };\n","ko.bindingHandlers['kgCell'] = (function () {\n    return {\n        'init': function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n            bindingContext.$userViewModel = bindingContext.$parent.$userViewModel;\n            var compile = function (html) {\n                var cell = $(html);\n                ko.applyBindings(bindingContext, cell[0]);\n                $(element).html(cell);\n            };\n            if (viewModel.cellTemplate.then) {\n                viewModel.cellTemplate.then(function(p) {\n                    compile(p);\n                });\n            } else {\n                compile(viewModel.cellTemplate);\n            }\n            return { controlsDescendantBindings: true };\n        }\n    };\n}());\n","ko.bindingHandlers['kgHeaderCell'] = (function () {\n    return {\n        'init': function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n            var newContext = bindingContext.extend({ $grid: bindingContext.$parent, $userViewModel: bindingContext.$parent.$userViewModel });\n            var compile = function (html) {\n                var headerCell = $(html);\n                ko.applyBindings(newContext, headerCell[0]);\n                $(element).html(headerCell);\n            };\n            if (viewModel.headerCellTemplate.then) {\n                viewModel.headerCellTemplate.then(function (p) {\n                    compile(p);\n                });\n            } else {\n                compile(viewModel.headerCellTemplate);\n            }\n            return { controlsDescendantBindings: true };\n        }\n    };\n}());","ko.bindingHandlers['kgHeaderRow'] = (function () {\n    return {\n        'init': function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n            bindingContext.$userViewModel = bindingContext.$data.$userViewModel;\n            var compile = function(html) {\n                var headerRow = $(html);\n                ko.applyBindings(bindingContext, headerRow[0]);\n                $(element).html(headerRow);\n            };\n            if (viewModel.headerRowTemplate.then) {\n                viewModel.headerRowTemplate.then(function (p) {\n                    compile(p);\n                });\n            } else {\n                compile(viewModel.headerRowTemplate);\n            }\n            return { controlsDescendantBindings: true };\n        }\n    };\n}());","ko.bindingHandlers['mouseEvents'] = (function () {\n    return {\n        'init': function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n            var eFuncs = valueAccessor();\n            if (eFuncs.mouseDown) {\n                $(element).mousedown(eFuncs.mouseDown);\n            }\n        }\n    };\n}());","ko.bindingHandlers['kgRow'] = (function () {\n    return {\n        'init': function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n            var row = valueAccessor();\n            var grid = row.$grid = bindingContext.$parent;\n            var source;\n            if (row.isAggRow) {\n                source = window.kg.aggregateTemplate();\n            } else {\n                source = grid.rowTemplate;\n            }\n            var compile = function(html) {\n                var rowElem = $(html);\n                row.$userViewModel = bindingContext.$parent.$userViewModel;\n                ko.applyBindings(row, rowElem[0]);\n                $(element).html(rowElem);\n            };\n            if (source.then) {\n                source.then(function (p) {\n                    compile(p);\n                });\n            } else {\n                compile(source);\n            }\n            return { controlsDescendantBindings: true };\n        }\n    };\n}());\n","ko.bindingHandlers['koGrid'] = (function () {\n    return {\n        'init': function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n            var options = valueAccessor();\n            var elem = $(element);\n            options.gridDim = new window.kg.Dimension({ outerHeight: ko.observable(elem.height()), outerWidth: ko.observable(elem.width()) });\n            var grid = new window.kg.Grid(options);\n            var gridElem = $(window.kg.defaultGridTemplate());\n            // if it is a string we can watch for data changes. otherwise you won't be able to update the grid data\n            options.data.subscribe(function () {\n                if (grid.$$selectionPhase) {\n                    return;\n                }\n                grid.searchProvider.evalFilter();\n                grid.refreshDomSizes();\n            });\n            // if columndefs are observable watch for changes and rebuild columns.\n            if (ko.isObservable(options.columnDefs)) {\n                options.columnDefs.subscribe(function (newDefs) {\n                    grid.columns([]);\n                    grid.config.columnDefs = newDefs;\n                    grid.buildColumns();\n                    grid.configureColumnWidths();\n                });\n            }\n            //set the right styling on the container\n            elem.addClass(\"koGrid\").addClass(grid.gridId.toString());\n            elem.append(gridElem);\n            grid.$userViewModel = bindingContext.$data;\n            ko.applyBindings(grid, gridElem[0]);\n            //walk the element's graph and the correct properties on the grid\n            window.kg.domUtilityService.AssignGridContainers(elem, grid);\n            grid.configureColumnWidths();\n            grid.refreshDomSizes();\n            //now use the manager to assign the event handlers\n            grid.eventProvider = new window.kg.EventProvider(grid);\n            //initialize plugins.\n            $.each(grid.config.plugins, function (i, p) {\n                if (typeof p.onGridInit === 'function') {\n                    p.onGridInit(grid);\n                }\n            });\n            window.kg.domUtilityService.BuildStyles(grid);\n            return { controlsDescendantBindings: true };\n        }\n    };\n}());","window.kg.Aggregate = function (aggEntity, rowFactory) {\n    var self = this;\n    self.index = 0;\n    self.offsetTop = ko.observable(0);\n    self.entity = aggEntity;\n    self.label = ko.observable(aggEntity.gLabel);\n    self.field = aggEntity.gField;\n    self.depth = aggEntity.gDepth;\n    self.parent = aggEntity.parent;\n    self.children = aggEntity.children;\n    self.aggChildren = aggEntity.aggChildren;\n    self.aggIndex = aggEntity.aggIndex;\n    self.collapsed = ko.observable(true);\n    self.isAggRow = true;\n    self.offsetLeft = ko.observable((aggEntity.gDepth * 25).toString() + 'px');\n    self.aggLabelFilter = aggEntity.aggLabelFilter;\n    self.toggleExpand = function() {\n        var c = self.collapsed();\n        self.collapsed(!c);\n        self.notifyChildren();\n    };\n    self.setExpand = function (state) {\n        self.collapsed(state);\n        self.notifyChildren();\n    };\n    self.notifyChildren = function() {\n        $.each(self.aggChildren, function (i, child) {\n            child.entity[KG_HIDDEN] = self.collapsed();\n            if (self.collapsed()) {\n                var c = self.collapsed();\n                child.setExpand(c);\n            }\n        });\n        $.each(self.children, function (i, child) {\n            child[KG_HIDDEN] = self.collapsed();\n        });\n        rowFactory.rowCache = [];\n        var foundMyself = false;\n        $.each(rowFactory.aggCache, function (i, agg) {\n            if (foundMyself) {\n                var offset = (30 * self.children.length);\n                var c = self.collapsed();\n                agg.offsetTop(c ? agg.offsetTop() - offset : agg.offsetTop() + offset);\n            } else {\n                if (i == self.aggIndex) {\n                    foundMyself = true;\n                }\n            }\n        });\n        rowFactory.renderedChange();\n    };\n    self.aggClass = ko.computed(function() {\n        return self.collapsed() ? \"kgAggArrowCollapsed\" : \"kgAggArrowExpanded\";\n    });\n    self.totalChildren = ko.computed(function() {\n        if (self.aggChildren.length > 0) {\n            var i = 0;\n            var recurse = function (cur) {\n                if (cur.aggChildren.length > 0) {\n                    $.each(cur.aggChildren, function (x, a) {\n                        recurse(a);\n                    });\n                } else {\n                    i += cur.children.length;\n                }\n            };\n            recurse(self);\n            return i;\n        } else {\n            return self.children.length;\n        }\n    });\n    self.selected = ko.observable(false);\n    self.isEven = ko.observable(false);\n    self.isOdd = ko.observable(false);\n    self.toggleSelected = function () { return true; };\n};\n","window.kg.Column = function (config, grid) {\n    var self = this,\n        colDef = config.colDef,\n\t\tdelay = 500,\n        clicks = 0,\n        timer = null;\n    self.eventTaget = undefined;\n    self.width = colDef.width;\n\tself.groupIndex = ko.observable(0);\n\tself.isGroupedBy = ko.observable(false);\n\tself.groupedByClass = ko.computed(function(){ return self.isGroupedBy() ? \"kgGroupedByIcon\": \"kgGroupIcon\";});\n\tself.sortable = ko.observable(false);\n\tself.resizable = ko.observable(false);\n    self.minWidth = !colDef.minWidth ? 50 : colDef.minWidth;\n    self.maxWidth = !colDef.maxWidth ? 9000 : colDef.maxWidth;\n    self.headerRowHeight = config.headerRowHeight;\n    self.displayName = ko.observable(colDef.displayName || colDef.field);\n    self.index = config.index;\n    self.isAggCol = config.isAggCol;\n    self.cellClass = ko.observable(colDef.cellClass || \"\");\n    self.cellFilter = colDef.cellFilter || colDef.cellFormatter;\n    self.field = colDef.field;\n    self.aggLabelFilter = colDef.cellFilter || colDef.cellFormatter || colDef.aggLabelFilter || colDef.aggLabelFormatter;\n    self._visible = ko.observable(window.kg.utils.isNullOrUndefined(colDef.visible) || colDef.visible);\n    self.visible = ko.computed({\n        read: function() {\n            return self._visible();\n        },\n        write: function(val) {\n            self.toggleVisible(val);\n        }\n    });\n    if (config.enableSort) {\n        self.sortable(window.kg.utils.isNullOrUndefined(colDef.sortable) || colDef.sortable);\n    }\n    if (config.enableResize) {\n        self.resizable(window.kg.utils.isNullOrUndefined(colDef.resizable) || colDef.resizable);\n    }\n    self.sortDirection = ko.observable(undefined);\n    self.sortingAlgorithm = colDef.sortFn;\n    self.headerClass = ko.observable(colDef.headerClass);\n    self.headerCellTemplate = colDef.headerCellTemplate || window.kg.defaultHeaderCellTemplate();\n    self.cellTemplate = colDef.cellTemplate || window.kg.defaultCellTemplate();\n    if (colDef.cellTemplate && !TEMPLATE_REGEXP.test(colDef.cellTemplate)) {\n        self.cellTemplate = window.kg.utils.getTemplatePromise(colDef.cellTemplate);\n    }\n    if (colDef.headerCellTemplate && !TEMPLATE_REGEXP.test(colDef.headerCellTemplate)) {\n        self.headerCellTemplate = window.kg.utils.getTemplatePromise(colDef.headerCellTemplate);\n    }\n    self.getProperty = function (row) {\n        var ret;\n        if (self.cellFilter) {\n            ret = self.cellFilter(row.getProperty(self.field));\n        } else {\n            ret = row.getProperty(self.field);\n        }\n        return ret;\n    };\n    self.toggleVisible = function (val) {\n        var v;\n        if (window.kg.utils.isNullOrUndefined(val) || typeof val == \"object\") {\n            v = !self._visible();\n        } else {\n            v = val;\n        }\n        self._visible(v);\n        window.kg.domUtilityService.BuildStyles(grid);\n    };\n\n    self.showSortButtonUp = ko.computed(function () {\n        return self.sortable ? self.sortDirection() === DESC : self.sortable;\n    });\n    self.showSortButtonDown = ko.computed(function () {\n        return self.sortable ? self.sortDirection() === ASC : self.sortable;\n    });     \n    self.noSortVisible = ko.computed(function () {\n        return !self.sortDirection();\n    });\n    self.sort = function () {\n        if (!self.sortable()) {\n            return true; // column sorting is disabled, do nothing\n        }\n        var dir = self.sortDirection() === ASC ? DESC : ASC;\n        self.sortDirection(dir);\n        config.sortCallback(self, dir);\n        return false;\n    };   \n    self.gripClick = function (data, event) {\n        event.stopPropagation();\n        clicks++;  //count clicks\n        if (clicks === 1) {\n            timer = setTimeout(function () {\n                //Here you can add a single click action.\n                clicks = 0;  //after action performed, reset counter\n            }, delay);\n        } else {\n            clearTimeout(timer);  //prevent single-click action\n            config.resizeOnDataCallback(self);  //perform double-click action\n            clicks = 0;  //after action performed, reset counter\n        }\n    };\n    self.gripOnMouseDown = function (event) {\n        event.stopPropagation();\n        if (event.ctrlKey) {\n            self.toggleVisible();\n            window.kg.domUtilityService.BuildStyles(grid);\n            grid.config.columnsChanged(grid.columns.peek());\n            return true;\n        }\n        self.eventTaget = event.target.parentElement;\n        self.eventTaget.style.cursor = 'col-resize';\n        self.startMousePosition = event.clientX;\n        self.origWidth = self.width;\n        $(document).mousemove(self.onMouseMove);\n        $(document).mouseup(self.gripOnMouseUp);\n        return false;\n    };\n    self.onMouseMove = function (event) {\n        event.stopPropagation();\n        var diff = event.clientX - self.startMousePosition;\n        var newWidth = diff + self.origWidth;\n        self.width = (newWidth < self.minWidth ? self.minWidth : (newWidth > self.maxWidth ? self.maxWidth : newWidth));\n        window.kg.domUtilityService.BuildStyles(grid);\n        return false;\n    };\n    self.gripOnMouseUp = function (event) {\n        event.stopPropagation();\n        $(document).off('mousemove');\n        $(document).off('mouseup');\n        self.eventTaget.style.cursor = self.sortable() ? 'pointer' : 'default';\n        self.eventTaget = undefined;\n        grid.config.columnsChanged(grid.columns.peek());\n        return false;\n    };\n};","window.kg.Dimension = function (options) {\n    this.outerHeight = null;\n    this.outerWidth = null;\n    $.extend(this, options);\n};","var getWidths = function () {\n    var $testContainer = $('<div></div>');\n    $testContainer.appendTo('body');\n    // 1. Run all the following measurements on startup!\n    //measure Scroll Bars\n    $testContainer.height(100).width(100).css(\"position\", \"absolute\").css(\"overflow\", \"scroll\");\n    $testContainer.append('<div style=\"height: 400px; width: 400px;\"></div>');\n    window.kg.domUtilityService.ScrollH = ($testContainer.height() - $testContainer[0].clientHeight);\n    window.kg.domUtilityService.ScrollW = ($testContainer.width() - $testContainer[0].clientWidth);\n    $testContainer.empty();\n    //clear styles\n    $testContainer.attr('style', '');\n    //measure letter sizes using a pretty typical font size and fat font-family\n    $testContainer.append('<span style=\"font-family: Verdana, Helvetica, Sans-Serif; font-size: 14px;\"><strong>M</strong></span>');\n    window.kg.domUtilityService.LetterW = $testContainer.children().first().width();\n    $testContainer.remove();\n};\nwindow.kg.domUtilityService = {\n    AssignGridContainers: function (rootEl, grid) {\n        grid.$root = $(rootEl);\n        //Headers\n        grid.$topPanel = grid.$root.find(\".kgTopPanel\");\n        grid.$groupPanel = grid.$root.find(\".kgGroupPanel\");\n        grid.$headerContainer = grid.$topPanel.find(\".kgHeaderContainer\");\n        grid.$headerScroller = grid.$topPanel.find(\".kgHeaderScroller\");\n        grid.$headers = grid.$headerScroller.children();\n        //Viewport\n        grid.$viewport = grid.$root.find(\".kgViewport\");\n        //Canvas\n        grid.$canvas = grid.$viewport.find(\".kgCanvas\");\n        //Footers\n        grid.$footerPanel = grid.$root.find(\".ngFooterPanel\");\n        window.kg.domUtilityService.UpdateGridLayout(grid);\n    },\n    UpdateGridLayout: function(grid) {\n        //catch this so we can return the viewer to their original scroll after the resize!\n        var scrollTop = grid.$viewport.scrollTop();\n        grid.elementDims.rootMaxW = grid.$root.width();\n        grid.elementDims.rootMaxH = grid.$root.height();\n        //check to see if anything has changed\n        grid.refreshDomSizes();\n        grid.adjustScrollTop(scrollTop, true); //ensure that the user stays scrolled where they were\n    },\n    BuildStyles: function(grid) {\n        var rowHeight = grid.config.rowHeight,\n            $style = grid.$styleSheet,\n            gridId = grid.gridId,\n            css,\n            cols = grid.visibleColumns(),\n            sumWidth = 0;\n\n        if (!$style) {\n            $style = $('#' + gridId);\n            if (!$style[0]) {\n                $style = $(\"<style id='\" + gridId + \"' type='text/css' rel='stylesheet' />\");\n                $style.appendTo('body');\n            }\n        }\n        $style.empty();\n        var trw = grid.totalRowWidth();\n        css = \".\" + gridId + \" .kgCanvas { width: \" + trw + \"px; }\"+\n              \".\" + gridId + \" .kgRow { width: \" + trw + \"px; }\" +\n              \".\" + gridId + \" .kgCell { height: \" + rowHeight + \"px; }\"+\n              \".\" + gridId + \" .kgCanvas { width: \" + trw + \"px; }\" +\n              \".\" + gridId + \" .kgHeaderCell { top: 0; bottom: 0; }\" +\n              \".\" + gridId + \" .kgHeaderScroller { width: \" + (trw + window.kg.domUtilityService.scrollH + 2) + \"px}\";\n        $.each(cols, function (i, col) {\n            css += \".\" + gridId + \" .col\" + i + \" { width: \" + col.width + \"px; left: \" + sumWidth + \"px; right: \" + (trw - sumWidth - col.width) + \"px; height: \" + rowHeight + \"px }\" +\n                   \".\" + gridId + \" .colt\" + i + \" { width: \" + col.width + \"px; }\";\n            sumWidth += col.width;\n        });\n        if (window.kg.utils.isIe) { // IE\n            $style[0].styleSheet.cssText = css;\n        } else {\n            $style.append(document.createTextNode(css));\n        }\n        grid.$styleSheet = $style;\n    },\n    ScrollH: 17, // default in IE, Chrome, & most browsers\n    ScrollW: 17, // default in IE, Chrome, & most browsers\n    LetterW: 10\n};\ngetWidths();\n","window.kg.EventProvider = function (grid) {\n    var self = this;\n    // The init method gets called during the ng-grid directive execution.\n    self.colToMove = undefined;\n\tself.groupToMove = undefined;\n    self.assignEvents = function () {\n        // Here we set the onmousedown event handler to the header container.\n\t\tif(grid.config.jqueryUIDraggable){\n\t\t\tgrid.$groupPanel.droppable({\n\t\t\t\taddClasses: false,\n\t\t\t\tdrop: function(event) {\n\t\t\t\t\tself.onGroupDrop(event);\n\t\t\t\t}\n\t\t\t});\n\t\t\t$(document).ready(self.setDraggables);\n\t\t} else {\n\t\t\tgrid.$groupPanel.on('mousedown', self.onGroupMouseDown).on('dragover', self.dragOver).on('drop', self.onGroupDrop);\n\t\t\tgrid.$headerScroller.on('mousedown', self.onHeaderMouseDown).on('dragover', self.dragOver).on('drop', self.onHeaderDrop);\n\t\t\tif (grid.config.enableRowReordering) {\n\t\t\t\tgrid.$viewport.on('mousedown', self.onRowMouseDown).on('dragover', self.dragOver).on('drop', self.onRowDrop);\n\t\t\t}\n\t\t\tself.setDraggables();\n\t\t}\n        grid.columns.subscribe(self.setDraggables);\n    };\n    self.dragOver = function(evt) {\n        evt.preventDefault();\n    };\n\n\t//For JQueryUI\n\tself.setDraggables = function(){\n\t\tif(!grid.config.jqueryUIDraggable){\n\t\t\tgrid.$root.find('.kgHeaderSortColumn').attr('draggable', 'true');\n\t\t\tif (navigator.userAgent.indexOf(\"MSIE\") != -1)\n\t\t\t{\n\t\t\t\t//call native IE dragDrop() to start dragging\n\t\t\t\tgrid.$root.find('.kgHeaderSortColumn').bind('selectstart', function () { this.dragDrop(); return false; });\n\t\t\t}\n\t\t} else {\n\t\t\tgrid.$root.find('.kgHeaderSortColumn').draggable({\n\t\t\t\thelper: 'clone',\n\t\t\t\tappendTo: 'body',\n\t\t\t\tstack: 'div',\n\t\t\t\taddClasses: false,\n\t\t\t\tstart: function(event){\n\t\t\t\t\tself.onHeaderMouseDown(event);\n\t\t\t\t}\n\t\t\t}).droppable({\n\t\t\t\tdrop: function(event) {\n\t\t\t\t\tself.onHeaderDrop(event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\n    self.onGroupMouseDown = function(event) {\n        var groupItem = $(event.target);\n        // Get the scope from the header container\n\t\tif(groupItem[0].className !='kgRemoveGroup'){\n\t\t    var groupItemScope = ko.dataFor(groupItem[0]);\n\t\t\tif (groupItemScope) {\n\t\t\t\t// set draggable events\n\t\t\t\tif(!grid.config.jqueryUIDraggable){\n\t\t\t\t\tgroupItem.attr('draggable', 'true');\n\t\t\t\t}\n\t\t\t\t// Save the column for later.\n\t\t\t\tself.groupToMove = { header: groupItem, groupName: groupItemScope, index: groupItemScope.groupIndex() - 1 };\n\t\t\t}\n\t\t} else {\n\t\t\tself.groupToMove = undefined;\n\t\t}\n    };\n\n    self.onGroupDrop = function(event) {\n        // clear out the colToMove object\n        var groupContainer;\n        var groupScope;\n        if (self.groupToMove) {\n            // Get the closest header to where we dropped\n            groupContainer = $(event.target).closest('.kgGroupElement'); // Get the scope from the header.\n            if (groupContainer.context.className =='kgGroupPanel') {\n                grid.configGroups.splice(self.groupToMove.index, 1);\n                grid.configGroups.push(self.groupToMove.groupName);\n            } else {\n                groupScope = ko.dataFor(groupContainer[0]);\n                if (groupScope) {\n                    // If we have the same column, do nothing.\n                    if (self.groupToMove.index != groupScope.groupIndex()) {\n\t\t\t\t\t\t// Splice the columns\n                        grid.configGroups.splice(self.groupToMove.index, 1);\n                        grid.configGroups.splice(groupScope.groupIndex(), 0, self.groupToMove.groupName);\n\t\t\t\t\t}\n                }\n            }\n\t\t\tself.groupToMove = undefined;\n\t\t\tgrid.fixGroupIndexes();\n        } else {\n\t\t\tif (grid.configGroups.indexOf(self.colToMove.col) == -1) {\n                groupContainer = $(event.target).closest('.kgGroupElement'); // Get the scope from the header.\n\t\t\t\tif (groupContainer.context.className =='kgGroupPanel' || groupContainer.context.className =='kgGroupPanelDescription') {\n\t\t\t\t    grid.groupBy(self.colToMove.col);\n\t\t\t\t} else {\n\t\t\t\t    groupScope = ko.dataFor(groupContainer[0]);\n\t\t\t\t    if (groupScope) {\n\t\t\t\t\t\t// Splice the columns\n\t\t\t\t        grid.removeGroup(groupScope.groupIndex());\n\t\t\t\t\t}\n\t\t\t\t}\n            }\n\t\t\tself.colToMove = undefined;\n        }\n    };\n\n    //Header functions\n    self.onHeaderMouseDown = function (event) {\n        // Get the closest header container from where we clicked.\n        var headerContainer = $(event.target).closest('.kgHeaderSortColumn');\n        if (!headerContainer[0]) {\n            return true;\n        }\n        // Get the scope from the header container\n\n        var headerScope = ko.dataFor(headerContainer[0]);\n        if (headerScope) {\n            // Save the column for later.\n            self.colToMove = { header: headerContainer, col: headerScope };\n        }\n        return true;\n    };\n\n    self.onHeaderDrop = function (event) {\n        if (!self.colToMove) {\n            return true;\n        }\n        // Get the closest header to where we dropped\n        var headerContainer = $(event.target).closest('.kgHeaderSortColumn');\n        if (!headerContainer[0]) {\n            return true;\n        }\n        // Get the scope from the header.\n        var headerScope = ko.dataFor(headerContainer[0]);\n        if (headerScope) {\n            // If we have the same column, do nothing.\n            if (self.colToMove.col == headerScope) {\n                return true;\n            }\n            // Splice the columns\n            var cols = grid.columns.peek();\n            cols.splice(self.colToMove.col.index, 1);\n            cols.splice(headerScope.index, 0, self.colToMove.col);\n            grid.fixColumnIndexes();\n            grid.columns(cols);\n            // Finally, rebuild the CSS styles.\n            window.kg.domUtilityService.BuildStyles(grid);\n            // clear out the colToMove object\n            self.colToMove = undefined;\n        }\n        return true;\n    };\n\n    // Row functions\n    self.onRowMouseDown = function (event) {\n        // Get the closest row element from where we clicked.\n        var targetRow = $(event.target).closest('.kgRow');\n        if (!targetRow[0]) {\n            return;\n        }\n        // Get the scope from the row element\n        var rowScope = ko.dataFor(targetRow[0]);\n        if (rowScope) {\n            // set draggable events\n            targetRow.attr('draggable', 'true');\n            // Save the row for later.\n            window.kg.eventStorage.rowToMove = { targetRow: targetRow, scope: rowScope };\n        }\n    };\n\n    self.onRowDrop = function (event) {\n        // Get the closest row to where we dropped\n        var targetRow = $(event.target).closest('.kgRow');\n        // Get the scope from the row element.\n        var rowScope = ko.dataFor(targetRow[0]);\n        if (rowScope) {\n            // If we have the same Row, do nothing.\n            var prevRow = window.kg.eventStorage.rowToMove;\n            if (prevRow.scope == rowScope) {\n                return;\n            }\n            // Splice the Rows via the actual datasource\n            var sd = grid.sortedData();\n            var i = sd.indexOf(prevRow.scope.entity);\n            var j = sd.indexOf(rowScope.entity);\n            grid.sortedData.splice(i, 1);\n            grid.sortedData.splice(j, 0, prevRow.scope.entity);\n            grid.searchProvider.evalFilter();\n            // clear out the rowToMove object\n            window.kg.eventStorage.rowToMove = undefined;\n            // if there isn't an apply already in progress lets start one\n        }\n    };\n    self.assignGridEventHandlers = function() {\n        grid.$viewport.scroll(function(e) {\n            var scrollLeft = e.target.scrollLeft,\n                scrollTop = e.target.scrollTop;\n            grid.adjustScrollLeft(scrollLeft);\n            grid.adjustScrollTop(scrollTop);\n        });\n        grid.$viewport.off('keydown');\n        grid.$viewport.on('keydown', function(e) {\n            return window.kg.moveSelectionHandler(grid, e);\n        });\n        //Chrome and firefox both need a tab index so the grid can recieve focus.\n        //need to give the grid a tabindex if it doesn't already have one so\n        //we'll just give it a tab index of the corresponding gridcache index\n        //that way we'll get the same result every time it is run.\n        //configurable within the options.\n        if (grid.config.tabIndex === -1) {\n            grid.$viewport.attr('tabIndex', window.kg.numberOfGrids);\n            window.kg.numberOfGrids++;\n        } else {\n            grid.$viewport.attr('tabIndex', grid.config.tabIndex);\n        }\n        $(window).resize(function() {\n            window.kg.domUtilityService.UpdateGridLayout(grid);\n            if (grid.config.maintainColumnRatios) {\n                grid.configureColumnWidths();\n            }\n        });\n    };\n    self.assignGridEventHandlers();\n    // In this example we want to assign grid events.\n    self.assignEvents();\n};\n","window.kg.Grid = function (options) {\n    var defaults = {\n            rowHeight: 30,\n            columnWidth: 100,\n            headerRowHeight: 30,\n            footerRowHeight: 55,\n            footerVisible: true,\n            displayFooter: undefined,\n            canSelectRows: true,\n            selectAllState: ko.observable(false),\n            data: ko.observableArray([]),\n            columnDefs: undefined,\n            selectedItems: ko.observableArray([]), // array, if multi turned off will have only one item in array\n            displaySelectionCheckbox: true, //toggles whether row selection check boxes appear\n            selectWithCheckboxOnly: false,\n            useExternalSorting: false,\n            sortInfo: ko.observable(undefined), // similar to filterInfo\n            multiSelect: true,\n            tabIndex: -1,\n            enableColumnResize: true,\n            enableSorting: true,\n            maintainColumnRatios: undefined,\n            beforeSelectionChange: function () { return true;},\n            afterSelectionChange: function () { },\n            columnsChanged: function() { },\n            rowTemplate: undefined,\n            headerRowTemplate: undefined,\n            jqueryUITheme: false,\n            jqueryUIDraggable: false,\n            plugins: [],\n            keepLastSelected: true,\n            groups: [],\n            showGroupPanel: false,\n            enableRowReordering: false,\n            showColumnMenu: true,\n            showFilter: true,\n            disableTextSelection: true,\n            filterOptions: {\n                filterText: ko.observable(\"\"),\n                useExternalFilter: false\n            },\n            //Paging\n            enablePaging: false,\n            pagingOptions: {\n                pageSizes: ko.observableArray([250, 500, 1000]), //page Sizes\n                pageSize: ko.observable(250), //Size of Paging data\n                totalServerItems: ko.observable(0), //how many items are on the server (for paging)\n                currentPage: ko.observable(1) //what page they are currently on\n            }\n        },\n        self = this;\n\n    self.maxCanvasHt = ko.observable(0);\n    //self vars\n    self.config = $.extend(defaults, options);\n    self.config.columnDefs = ko.utils.unwrapObservable(options.columnDefs);\n    self.gridId = \"ng\" + window.kg.utils.newId();\n    self.$root = null; //this is the root element that is passed in with the binding handler\n\tself.$groupPanel = null;\n    self.$topPanel = null;\n    self.$headerContainer = null;\n    self.$headerScroller = null;\n    self.$headers = null;\n    self.$viewport = null;\n    self.$canvas = null;\n    self.rootDim = self.config.gridDim;\n    self.sortInfo = ko.isObservable(self.config.sortInfo) ? self.config.sortInfo : ko.observable(self.config.sortInfo);\n    self.sortedData = self.config.data;\n    self.lateBindColumns = false;\n    self.filteredData = ko.observableArray([]);\n    self.lastSortedColumn = undefined;\n    self.showFilter = self.config.showFilter;\n    self.filterText = self.config.filterOptions.filterText;\n    self.disableTextSelection = ko.observable(self.config.disableTextSelection);\n    self.calcMaxCanvasHeight = function() {\n        return (self.configGroups().length > 0) ? (self.rowFactory.parsedData.filter(function (e) {\n            return e[KG_HIDDEN] === false;\n        }).length * self.config.rowHeight) : (self.filteredData().length * self.config.rowHeight);\n    };\n    self.elementDims = {\n        scrollW: 0,\n        scrollH: 0,\n        rowIndexCellW: 25,\n        rowSelectedCellW: 25,\n        rootMaxW: 0,\n        rootMaxH: 0\n    };\n    //self funcs\n    self.setRenderedRows = function (newRows) {\n        self.renderedRows(newRows);\n        self.refreshDomSizes();\n    };\n    self.minRowsToRender = function () {\n        var viewportH = self.viewportDimHeight() || 1;\n        return Math.floor(viewportH / self.config.rowHeight);\n    };\n    self.refreshDomSizes = function () {\n        self.rootDim.outerWidth(self.elementDims.rootMaxW);\n        self.rootDim.outerHeight(self.elementDims.rootMaxH);\n        self.maxCanvasHt(self.calcMaxCanvasHeight());\n    };\n    self.buildColumnDefsFromData = function () {\n        var sd = self.sortedData();\n        if (!self.config.columnDefs) {\n            self.config.columnDefs = [];\n        }\n        if (!sd || !sd[0]) {\n            self.lateBoundColumns = true;\n            return;\n        }\n        var item;\n        item = sd[0];\n\n        window.kg.utils.forIn(item, function (prop, propName) {\n            if (propName != SELECTED_PROP) {\n                self.config.columnDefs.push({\n                    field: propName\n                });\n            }\n        });\n    };\n    self.buildColumns = function () {\n        var columnDefs = self.config.columnDefs,\n            cols = [];\n\n        if (!columnDefs) {\n            self.buildColumnDefsFromData();\n            columnDefs = self.config.columnDefs;\n        }\n        if (self.config.displaySelectionCheckbox && self.config.canSelectRows) {\n            columnDefs.splice(0, 0, {\n                field: '\\u2714',\n                width: self.elementDims.rowSelectedCellW,\n                sortable: false,\n                resizable: false,\n                headerCellTemplate: '<input class=\"kgSelectionHeader\" type=\"checkbox\" data-bind=\"visible: $grid.multiSelect, checked: $grid.allSelected\"/>',\n                cellTemplate: '<div class=\"kgSelectionCell\"><input class=\"kgSelectionCheckbox\" type=\"checkbox\" data-bind=\"checked: $parent.selected\" /></div>'\n            });\n        }\n        if (columnDefs.length > 0) {\n            $.each(columnDefs, function (i, colDef) {\n                var column = new window.kg.Column({\n                    colDef: colDef,\n                    index: i,\n                    headerRowHeight: self.config.headerRowHeight,\n                    sortCallback: self.sortData,\n                    resizeOnDataCallback: self.resizeOnData,\n                    enableResize: self.config.enableColumnResize,\n                    enableSort: self.config.enableSorting\n                }, self);\n                cols.push(column);\n                var indx = self.config.groups.indexOf(colDef.field);\n                if (indx != -1) {\n                    self.configGroups.splice(indx, 0, column);\n                }\n            });\n            self.columns(cols);\n        }\n    };\n    self.configureColumnWidths = function() {\n        var cols = self.config.columnDefs;\n        var numOfCols = cols.length,\n            asterisksArray = [],\n            percentArray = [],\n            asteriskNum = 0,\n            totalWidth = 0;\n        var columns = self.columns();\n        $.each(cols, function (i, col) {\n            var isPercent = false, t = undefined;\n            //if width is not defined, set it to a single star\n            if (window.kg.utils.isNullOrUndefined(col.width)) {\n                col.width = \"*\";\n            } else { // get column width\n                isPercent = isNaN(col.width) ? window.kg.utils.endsWith(col.width, \"%\") : false;\n                t = isPercent ? col.width : parseInt(col.width, 10);\n            }\n            // check if it is a number\n            if (isNaN(t)) {\n                t = col.width;\n                // figure out if the width is defined or if we need to calculate it\n                if (t == 'auto') { // set it for now until we have data and subscribe when it changes so we can set the width.\n                    columns[i].width = columns[i].minWidth;\n                    var temp = columns[i];\n                    $(document).ready(function() { self.resizeOnData(temp, true); });\n                    return;\n                } else if (t.indexOf(\"*\") != -1) {\n                        asteriskNum += t.length;\n                        col.index = i;\n                        asterisksArray.push(col);\n                        return;\n                } else if (isPercent) { // If the width is a percentage, save it until the very last.\n                    col.index = i;\n                    percentArray.push(col);\n                    return;\n                } else { // we can't parse the width so lets throw an error.\n                    throw \"unable to parse column width, use percentage (\\\"10%\\\",\\\"20%\\\", etc...) or \\\"*\\\" to use remaining width of grid\";\n                }\n            } else {\n                totalWidth += columns[i].width = parseInt(col.width, 10);\n            }\n        });\n        // check if we saved any asterisk columns for calculating later\n        if (asterisksArray.length > 0) {\n            self.config.maintainColumnRatios === false ? $.noop() : self.config.maintainColumnRatios = true;\n            // get the remaining width\n            var remainingWidth = self.rootDim.outerWidth() - totalWidth;\n            // calculate the weight of each asterisk rounded down\n            var asteriskVal = Math.floor(remainingWidth / asteriskNum);\n            // set the width of each column based on the number of stars\n            $.each(asterisksArray, function (i, col) {\n\t\t\t\tvar t = col.width.length;\n                columns[col.index].width = asteriskVal * t;\n                //check if we are on the last column\n                if (col.index + 1 == numOfCols) {\n                    var offset = 2; //We're going to remove 2 px so we won't overlflow the viwport by default\n                    // are we overflowing?\n                    if (self.maxCanvasHt() > self.viewportDimHeight()) {\n                        //compensate for scrollbar\n                        offset += window.kg.domUtilityService.ScrollW;\n                    }\n                    columns[col.index].width -= offset;\n                }\n                totalWidth += columns[col.index].width;\n            });\n        }\n        // Now we check if we saved any percentage columns for calculating last\n        if (percentArray.length > 0) {\n            // do the math\n            $.each(percentArray, function (i, col) {\n                var t = col.width;\n                columns[col.index].width = Math.floor(self.rootDim.outerWidth() * (parseInt(t.slice(0, -1), 10) / 100));\n            });\n        }\n        self.columns(columns);\n        window.kg.domUtilityService.BuildStyles(self);\n    };\n    self.init = function () {\n        //factories and services\n        self.selectionService = new window.kg.SelectionService(self);\n        self.rowFactory = new window.kg.RowFactory(self);\n        self.selectionService.Initialize(self.rowFactory);\n        self.searchProvider = new window.kg.SearchProvider(self);\n        self.styleProvider = new window.kg.StyleProvider(self);\n        self.buildColumns();\n        window.kg.sortService.columns = self.columns;\n        self.configGroups.subscribe(function (a) {\n            if (!a) {\n                return;\n            }\n            var tempArr = [];\n            $.each(a, function (i, item) {\n\t\t\t\tif(item){\n\t\t\t\t\ttempArr.push(item.field || item);\n\t\t\t\t}\n            });\n            self.config.groups = tempArr;\n            self.rowFactory.filteredDataChanged();\n        });\n        self.filteredData.subscribe(function () {\n            if (self.$$selectionPhase) {\n                return;\n            }\n\t\t\tself.maxCanvasHt(self.calcMaxCanvasHeight());\n\t\t\tif (!self.isSorting) {\n\t\t\t    self.configureColumnWidths();\n\t\t\t}\n\t\t});\n        self.maxCanvasHt(self.calcMaxCanvasHeight());\n        self.searchProvider.evalFilter();\n        self.refreshDomSizes();\n    };\n    self.prevScrollTop = 0;\n    self.prevScrollIndex = 0;\n    self.adjustScrollTop = function (scrollTop, force) {\n        if (self.prevScrollTop === scrollTop && !force) { return; }\n        var rowIndex = Math.floor(scrollTop / self.config.rowHeight);\n        // Have we hit the threshold going down?\n        if (self.prevScrollTop < scrollTop && rowIndex < self.prevScrollIndex + SCROLL_THRESHOLD) {\n            return;\n        }\n        //Have we hit the threshold going up?\n        if (self.prevScrollTop > scrollTop && rowIndex > self.prevScrollIndex - SCROLL_THRESHOLD) {\n            return;\n        }\n        self.prevScrollTop = scrollTop;\n        self.rowFactory.UpdateViewableRange(new window.kg.Range(Math.max(0, rowIndex - EXCESS_ROWS), rowIndex + self.minRowsToRender() + EXCESS_ROWS));\n        self.prevScrollIndex = rowIndex;\n    };\n    self.adjustScrollLeft = function (scrollLeft) {\n        if (self.$headerContainer) {\n            self.$headerContainer.scrollLeft(scrollLeft);\n        }\n    };\n    self.resizeOnData = function (col) {\n        // we calculate the longest data.\n        var longest = col.minWidth;\n        var arr = window.kg.utils.getElementsByClassName('col' + col.index);\n        $.each(arr, function (index, elem) {\n            var i;\n            if (index === 0) {\n                var kgHeaderText = $(elem).find('.kgHeaderText');\n                i = window.kg.utils.visualLength(kgHeaderText) + 10;// +10 some margin\n            } else {\n                var ngCellText = $(elem).find('.kgCellText');\n                i = window.kg.utils.visualLength(ngCellText) + 10; // +10 some margin\n            }\n            if (i > longest) {\n                longest = i;\n            }\n        });\n        col.width = longest = Math.min(col.maxWidth, longest + 7); // + 7 px to make it look decent.\n        window.kg.domUtilityService.BuildStyles(self);\n    };\n    self.sortData = function (col, direction) {\n        // if external sorting is being used, do nothing.\n        self.isSorting = true;\n        self.sortInfo({\n            column: col,\n            direction: direction\n        });\n        self.clearSortingData(col);\n        if(!self.config.useExternalSorting){\n            window.kg.sortService.Sort(self.sortInfo.peek(), self.sortedData);\n        } else {\n            self.config.sortInfo(self.sortInfo.peek());\n        }\n        self.lastSortedColumn = col;\n        self.isSorting = false;\n    };\n    self.clearSortingData = function (col) {\n        if (!col) {\n            $.each(self.columns(), function (i, c) {\n                c.sortDirection(\"\");\n            });\n        } else if (self.lastSortedColumn && col != self.lastSortedColumn) {\n            self.lastSortedColumn.sortDirection(\"\");\n        }\n    };\n    self.fixColumnIndexes = function () {\n        self.$$indexPhase = true;\n        //fix column indexes\n        var cols = self.columns.peek();\n        $.each(cols, function (i, col) {\n            col.index = i;\n        });\n        self.$$indexPhase = false;\n    };\n    //self vars\n    self.elementsNeedMeasuring = true;\n    self.columns = ko.observableArray([]);\n    self.columns.subscribe(function(newCols) {\n        self.config.columnsChanged(newCols);\n    });\n    self.renderedRows = ko.observableArray([]);\n    self.headerRow = null;\n    self.rowHeight = self.config.rowHeight;\n\tself.jqueryUITheme = ko.observable(self.config.jqueryUITheme);\n    self.footer = null;\n    self.selectedItems = self.config.selectedItems;\n    self.multiSelect = self.config.multiSelect;\n    self.footerVisible = window.kg.utils.isNullOrUndefined(self.config.displayFooter) ? self.config.footerVisible : self.config.displayFooter;\n    self.config.footerRowHeight = self.footerVisible ? self.config.footerRowHeight : 0;\n\tself.showColumnMenu = self.config.showColumnMenu;\n    self.showMenu = ko.observable(false);\n    self.configGroups = ko.observableArray([]);\n\n    //Paging\n    self.enablePaging = self.config.enablePaging;\n    self.pagingOptions = self.config.pagingOptions;\n    //Templates\n    self.rowTemplate = self.config.rowTemplate || window.kg.defaultRowTemplate();\n    self.headerRowTemplate = self.config.headerRowTemplate || window.kg.defaultHeaderRowTemplate();\n    if (self.config.rowTemplate && !TEMPLATE_REGEXP.test(self.config.rowTemplate)) {\n        self.rowTemplate = window.kg.utils.getTemplatePromise(self.config.rowTemplate);\n    }\n    if (self.config.headerRowTemplate && !TEMPLATE_REGEXP.test(self.config.headerRowTemplate)) {\n        self.headerRowTemplate = window.kg.utils.getTemplatePromise(self.config.headerRowTemplate);\n    }\n    //scope funcs\n    self.visibleColumns = ko.computed(function () {\n        var cols = self.columns();\n        return cols.filter(function (col) {\n            var isVis = col.visible();\n            return isVis;\n        });\n    });\n    self.nonAggColumns = ko.computed(function () {\n        return self.columns().filter(function (col) {\n            return !col.isAggCol;\n        });\n    });\n    self.toggleShowMenu = function () {\n        self.showMenu(!self.showMenu());\n    };\n    self.allSelected = self.config.selectAllState;\n    self.allSelected.subscribe(function (state) {\n        if (self.config.beforeSelectionChange(self.sortedData.peek(), this)) {\n            self.selectionService.toggleSelectAll(state);\n            self.config.afterSelectionChange(self.selectedItems.peek(), this);\n        }\n    });\n    self.totalFilteredItemsLength = ko.computed(function () {\n        return self.filteredData().length;\n    });\n\tself.showGroupPanel = ko.computed(function(){\n\t\treturn self.config.showGroupPanel;\n\t});\n\tself.topPanelHeight = ko.observable(self.config.showGroupPanel === true ? (self.config.headerRowHeight * 2) : self.config.headerRowHeight);\n\tself.viewportDimHeight = ko.computed(function () {\n        return Math.max(0, self.rootDim.outerHeight() - self.topPanelHeight() - self.config.footerRowHeight - 2);\n    });\n\tself.groupBy = function (col) {\n\t    if (self.sortedData().length < 1) {\n\t        return;\n\t    }\n        var indx = self.configGroups().indexOf(col);\n        if (indx == -1) {\n\t\t\tcol.isGroupedBy(true);\n            self.configGroups.push(col);\n\t\t\tcol.groupIndex(self.configGroups().length);\n        } else {\n\t\t\tself.removeGroup(indx);\n        }\n        window.kg.domUtilityService.BuildStyles(self);\n    };\n    self.removeGroup = function(index) {\n\t\tvar col = self.columns().filter(function(item){\n\t\t\treturn item.groupIndex() == (index + 1);\n\t\t})[0];\n\t\tcol.isGroupedBy(false);\n\t\tcol.groupIndex(0);\n        self.columns.splice(index, 1);\n        self.configGroups.splice(index, 1);\n\t\tself.fixGroupIndexes();\n        if (self.configGroups().length === 0) {\n            self.fixColumnIndexes();\n        }\n        window.kg.domUtilityService.BuildStyles(self);\n    };\n\tself.fixGroupIndexes = function(){\n\t\t$.each(self.configGroups(), function(i,item){\n\t\t\titem.groupIndex(i + 1);\n\t\t});\n\t};\n    self.totalRowWidth = function () {\n        var totalWidth = 0,\n            cols = self.visibleColumns();\n        $.each(cols, function (i, col) {\n            totalWidth += col.width;\n        });\n        return totalWidth;\n    };\n    self.headerScrollerDim = function () {\n        var viewportH = self.viewportDimHeight(),\n            maxHeight = self.maxCanvasHt(),\n            vScrollBarIsOpen = (maxHeight > viewportH),\n            newDim = new window.kg.Dimension();\n\n        newDim.autoFitHeight = true;\n        newDim.outerWidth = self.totalRowWidth();\n        if (vScrollBarIsOpen) { newDim.outerWidth += self.elementDims.scrollW; }\n        else if ((maxHeight - viewportH) <= self.elementDims.scrollH) { //if the horizontal scroll is open it forces the viewport to be smaller\n            newDim.outerWidth += self.elementDims.scrollW;\n        }\n        return newDim;\n    };\n    //footer\n    self.jqueryUITheme = self.config.jqueryUITheme;\n    self.maxRows = ko.observable(Math.max(self.config.pagingOptions.totalServerItems() || self.sortedData().length, 1));\n    self.maxRowsDisplay = ko.computed(function () {\n        return self.maxRows();\n    });\n    self.multiSelect = ko.observable((self.config.canSelectRows && self.config.multiSelect));\n    self.selectedItemCount = ko.computed(function () {\n        return self.selectedItems().length;\n    });\n    self.maxPages = ko.computed(function () {\n        self.maxRows(Math.max(self.config.pagingOptions.totalServerItems() || self.sortedData().length, 1));\n        return Math.ceil(self.maxRows() / self.pagingOptions.pageSize());\n    });\n    self.pageForward = function () {\n        var page = self.config.pagingOptions.currentPage();\n        self.config.pagingOptions.currentPage(Math.min(page + 1, self.maxPages()));\n    };\n    self.pageBackward = function () {\n        var page = self.config.pagingOptions.currentPage();\n        self.config.pagingOptions.currentPage(Math.max(page - 1, 1));\n    };\n    self.pageToFirst = function () {\n        self.config.pagingOptions.currentPage(1);\n    };\n    self.pageToLast = function () {\n        var maxPages = self.maxPages();\n        self.config.pagingOptions.currentPage(maxPages);\n    };\n    self.cantPageForward = ko.computed(function () {\n        var curPage = self.config.pagingOptions.currentPage();\n        var maxPages = self.maxPages();\n        return !(curPage < maxPages);\n    });\n    self.cantPageBackward = ko.computed(function () {\n        var curPage = self.config.pagingOptions.currentPage();\n        return !(curPage > 1);\n    });\n    //call init\n    self.init();\n};\n","kg.Range = function (top, bottom) {\n    this.topRow = top;\n    this.bottomRow = bottom;\n};","window.kg.Row = function (entity, config, selectionService) {\n    var self = this; // constant for the selection property that we add to each data item\n\n    self.canSelectRows = config.canSelectRows;\n\n    self.rowClasses = config.rowClasses;\n    self.selectedItems = config.selectedItems;\n    self.entity = entity;\n    self.selectionService = selectionService;\n\n    self.selected = ko.observable(false);\n    self.continueSelection = function(event) {\n        self.selectionService.ChangeSelection(self, event);\n    };\n    self.toggleSelected = function (row, event) {\n        if (!self.canSelectRows) {\n            return true;\n        }\n        var element = event.target || event;\n        //check and make sure its not the bubbling up of our checked 'click' event\n        if (element.type == \"checkbox\") {\n            self.selected(!self.selected());\n        }\n        if (config.selectWithCheckboxOnly && element.type != \"checkbox\"){\n            return true;\n        } else {\n            if (self.beforeSelectionChange(self, event)) {\n                self.continueSelection(event);\n                return self.afterSelectionChange(self, event);\n            }\n        }\n        return false;\n    };\n    //selectify the entity\n    if (self.entity[SELECTED_PROP] === undefined) {\n        self.entity[SELECTED_PROP] = false;\n    } else {\n        // or else maintain the selection set by the entity.\n        self.selectionService.setSelection(self, self.entity[SELECTED_PROP]);\n    }\n    self.rowIndex = ko.observable(0);\n    self.offsetTop = ko.observable(\"0px\");\n    self.rowDisplayIndex = 0;\n    self.isEven = ko.computed(function () {\n        if (self.rowIndex() % 2 === 0) {\n            return true;\n        }\n        return false;\n    });\n    self.isOdd = ko.computed(function () {\n        if (self.rowIndex() % 2 !== 0) {\n            return true;\n        }\n        return false;\n    });\n    self.beforeSelectionChange = config.beforeSelectionChangeCallback;\n    self.afterSelectionChange = config.afterSelectionChangeCallback;\n    self.propertyCache = {};\n    self.getProperty = function (path) {\n        return self.propertyCache[path] || (self.propertyCache[path] = window.kg.utils.evalProperty(self.entity, path));\n    };\n};\n","window.kg.RowFactory = function (grid) {\n    var self = this;\n    // we cache rows when they are built, and then blow the cache away when sorting\n    self.rowCache = [];\n    self.aggCache = {};\n    self.parentCache = []; // Used for grouping and is cleared each time groups are calulated.\n    self.dataChanged = true;\n    self.parsedData = [];\n    self.rowConfig = {};\n    self.selectionService = grid.selectionService;\n    self.rowHeight = 30;\n    self.numberOfAggregates = 0;\n    self.groupedData = undefined;\n    self.rowHeight = grid.config.rowHeight;\n    self.rowConfig = {\n        canSelectRows: grid.config.canSelectRows,\n        rowClasses: grid.config.rowClasses,\n        selectedItems: grid.config.selectedItems,\n        selectWithCheckboxOnly: grid.config.selectWithCheckboxOnly,\n        beforeSelectionChangeCallback: grid.config.beforeSelectionChange,\n        afterSelectionChangeCallback: grid.config.afterSelectionChange\n    };\n\n    self.renderedRange = new window.kg.Range(0, grid.minRowsToRender() + EXCESS_ROWS);\n    // Builds rows for each data item in the 'filteredData'\n    // @entity - the data item\n    // @rowIndex - the index of the row\n    self.buildEntityRow = function(entity, rowIndex) {\n        var row = self.rowCache[rowIndex]; // first check to see if we've already built it\n        if (!row) {\n            // build the row\n            row = new window.kg.Row(entity, self.rowConfig, self.selectionService);\n            row.rowIndex(rowIndex + 1); //not a zero-based rowIndex\n            row.offsetTop((self.rowHeight * rowIndex).toString() + 'px');\n            row.selected(entity[SELECTED_PROP]);\n            // finally cache it for the next round\n            self.rowCache[rowIndex] = row;\n        }\n        return row;\n    };\n\n    self.buildAggregateRow = function(aggEntity, rowIndex) {\n        var agg = self.aggCache[aggEntity.aggIndex]; // first check to see if we've already built it\n        if (!agg) {\n            // build the row\n            agg = new window.kg.Aggregate(aggEntity, self);\n            self.aggCache[aggEntity.aggIndex] = agg;\n        }\n        agg.index = rowIndex + 1; //not a zero-based rowIndex\n        agg.offsetTop((self.rowHeight * rowIndex).toString() + 'px');\n        return agg;\n    };\n    self.UpdateViewableRange = function(newRange) {\n        self.renderedRange = newRange;\n        self.renderedChange();\n    };\n    self.filteredDataChanged = function() {\n        // check for latebound autogenerated columns\n        if (grid.lateBoundColumns && grid.filteredData().length > 1) {\n            grid.config.columnDefs = undefined;\n            grid.buildColumns();\n            grid.lateBoundColumns = false;\n        }\n        self.dataChanged = true;\n        self.rowCache = []; //if data source changes, kill this!\n        if (grid.config.groups.length > 0) {\n            self.getGrouping(grid.config.groups);\n        }\n        self.UpdateViewableRange(self.renderedRange);\n    };\n\n    self.renderedChange = function() {\n        if (!self.groupedData || grid.config.groups.length < 1) {\n            self.renderedChangeNoGroups();\n            grid.refreshDomSizes();\n            return;\n        }\n        self.parentCache = [];\n        var rowArr = [];\n        var dataArray = self.parsedData.filter(function(e) {\n            return e[KG_HIDDEN] === false;\n        }).slice(self.renderedRange.topRow, self.renderedRange.bottomRow);\n        $.each(dataArray, function (indx, item) {\n            var row;\n            if (item.isAggRow) {\n                row = self.buildAggregateRow(item, self.renderedRange.topRow + indx);\n            } else {\n                row = self.buildEntityRow(item, self.renderedRange.topRow + indx);\n            }\n            //add the row to our return array\n            rowArr.push(row);\n        });\n        grid.setRenderedRows(rowArr);\n        grid.refreshDomSizes();\n    };\n\n    self.renderedChangeNoGroups = function() {\n        var rowArr = [];\n        var dataArr = grid.filteredData.slice(self.renderedRange.topRow, self.renderedRange.bottomRow);\n        $.each(dataArr, function (i, item) {\n            var row = self.buildEntityRow(item, self.renderedRange.topRow + i);\n            //add the row to our return array\n            rowArr.push(row);\n        });\n        grid.setRenderedRows(rowArr);\n    };\n\n    //magical recursion. it works. I swear it. I figured it out in the shower one day.\n    self.parseGroupData = function(g) {\n        if (g.values) {\n            $.each(g.values, function (i, item) {\n                // get the last parent in the array because that's where our children want to be\n                self.parentCache[self.parentCache.length - 1].children.push(item);\n                //add the row to our return array\n                self.parsedData.push(item);\n            });\n        } else {\n            for (var prop in g) {\n                // exclude the meta properties.\n                if (prop == KG_FIELD || prop == KG_DEPTH || prop == KG_COLUMN) {\n                    continue;\n                } else if (g.hasOwnProperty(prop)) {\n                    //build the aggregate row\n                    var agg = self.buildAggregateRow({\n                        gField: g[KG_FIELD],\n                        gLabel: prop,\n                        gDepth: g[KG_DEPTH],\n                        isAggRow: true,\n                        '_kg_hidden_': false,\n                        children: [],\n                        aggChildren: [],\n                        aggIndex: self.numberOfAggregates,\n                        aggLabelFilter: g[KG_COLUMN].aggLabelFilter\n                    }, 0);\n                    self.numberOfAggregates++;\n                    //set the aggregate parent to the parent in the array that is one less deep.\n                    agg.parent = self.parentCache[agg.depth - 1];\n                    // if we have a parent, set the parent to not be collapsed and append the current agg to its children\n                    if (agg.parent) {\n                        agg.parent.collapsed(false);\n                        agg.parent.aggChildren.push(agg);\n                    }\n                    // add the aggregate row to the parsed data.\n                    self.parsedData.push(agg.entity);\n                    // the current aggregate now the parent of the current depth\n                    self.parentCache[agg.depth] = agg;\n                    // dig deeper for more aggregates or children.\n                    self.parseGroupData(g[prop]);\n                }\n            }\n        }\n    };\n    //Shuffle the data into their respective groupings.\n    self.getGrouping = function(groups) {\n        self.aggCache = [];\n        self.rowCache = [];\n        self.numberOfAggregates = 0;\n        self.groupedData = {};\n        // Here we set the onmousedown event handler to the header container.\n        var data = grid.filteredData();\n        var maxDepth = groups.length;\n        var cols = grid.columns();\n\n        $.each(data, function (i, item) {\n            item[KG_HIDDEN] = true;\n            var ptr = self.groupedData;\n            $.each(groups, function(depth, group) {\n                if (!cols[depth].isAggCol && depth <= maxDepth) {\n                    grid.columns.splice(item.gDepth, 0, new window.kg.Column({\n                        colDef: {\n                            field: '',\n                            width: 25,\n                            sortable: false,\n                            resizable: false,\n                            headerCellTemplate: '<div class=\"kgAggHeader\"></div>'\n                        },\n                        isAggCol: true,\n                        index: item.gDepth,\n                        headerRowHeight: grid.config.headerRowHeight\n                    }));\n                    window.kg.domUtilityService.BuildStyles(grid);\n                }\n                var col = cols.filter(function (c) { return c.field == group; })[0];\n                var val = window.kg.utils.evalProperty(item, group);\n                if (col.cellFilter) {\n                    val = col.cellFilter(val);\n                }\n                val = val ? val.toString() : 'null';\n                if (!ptr[val]) {\n                    ptr[val] = {};\n                }\n                if (!ptr[KG_FIELD]) {\n                    ptr[KG_FIELD] = group;\n                }\n                if (!ptr[KG_DEPTH]) {\n                    ptr[KG_DEPTH] = depth;\n                }\n                if (!ptr[KG_COLUMN]) {\n                    ptr[KG_COLUMN] = col;\n                }\n                ptr = ptr[val];\n            });\n            if (!ptr.values) {\n                ptr.values = [];\n            }\n            ptr.values.push(item);\n        });\n        grid.fixColumnIndexes();\n        self.parsedData.length = 0;\n        self.parseGroupData(self.groupedData);\n    };\n\n    if (grid.config.groups.length > 0 && grid.filteredData().length > 0) {\n        self.getGrouping(grid.config.groups);\n    }\n};\n","window.kg.SearchProvider = function (grid) {\n    var self = this,\n        searchConditions = [],\n        lastSearchStr;\n    self.extFilter = grid.config.filterOptions.useExternalFilter;\n    self.showFilter = grid.config.showFilter;\n    self.filterText = grid.config.filterOptions.filterText;\n    self.throttle = grid.config.filterOptions.filterThrottle;\n    self.fieldMap = {};\n    self.evalFilter = function () {\n        if (searchConditions.length === 0) {\n            grid.filteredData(grid.sortedData.peek().filter(function(item) {\n                return !item._destroy;\n            }));\n        } else {\n            grid.filteredData(grid.sortedData.peek().filter(function(item) {\n                if (item._destroy) {\n                    return false;\n                }\n\n                for (var i = 0, len = searchConditions.length; i < len; i++) {\n                    var condition = searchConditions[i];\n                    //Search entire row\n                    if (!condition.column) {\n                        for (var prop in item) {\n                            if (item.hasOwnProperty(prop)) {\n                                var pVal = ko.utils.unwrapObservable(item[prop]);\n                                if (pVal && condition.regex.test(pVal.toString())) {\n                                    return true;\n                                }\n                            }\n                        }\n                        return false;\n                    }\n                    //Search by column.\n                    var field = ko.utils.unwrapObservable(item[condition.column]) || ko.utils.unwrapObservable(item[self.fieldMap[condition.columnDisplay]]);\n                    if (!field || !condition.regex.test(field.toString())) {\n                        return false;\n                    }\n                }\n                return true;\n            }));\n        }\n        grid.rowFactory.filteredDataChanged();\n    };\n    var getRegExp = function(str, modifiers) {\n        try {\n            return new RegExp(str, modifiers);\n        } catch(err) {\n            //Escape all RegExp metacharacters.\n            return new RegExp(str.replace(/(\\^|\\$|\\(|\\)|\\<|\\>|\\[|\\]|\\{|\\}|\\\\|\\||\\.|\\*|\\+|\\?)/g, '\\\\$1'));\n        }\n    };\n    var buildSearchConditions = function (a) {\n        //reset.\n        searchConditions = [];\n        var qStr;\n        if (!(qStr = $.trim(a))) {\n            return;\n        }\n        var columnFilters = qStr.split(\";\");\n        $.each(columnFilters, function (i, filter) {\n            var args = filter.split(':');\n            if (args.length > 1) {\n                var columnName = $.trim(args[0]);\n                var columnValue = $.trim(args[1]);\n                if (columnName && columnValue) {\n                    searchConditions.push({\n                        column: columnName,\n                        columnDisplay: columnName.replace(/\\s+/g, '').toLowerCase(),\n                        regex: getRegExp(columnValue, 'i')\n                    });\n                }\n            } else {\n                var val = $.trim(args[0]);\n                if (val) {\n                    searchConditions.push({\n                        column: '',\n                        regex: getRegExp(val, 'i')\n                    });\n                }\n            }\n        });\n    };\n\n    var filterTextComputed = ko.computed(function () {\n        var a = self.filterText();\n        if (!self.extFilter && a != lastSearchStr) {\n            //To prevent circular dependency when throttle is enabled.\n            lastSearchStr = a;\n            buildSearchConditions(a);\n            self.evalFilter();\n        }\n    });\n    if (typeof self.throttle === 'number') {\n        filterTextComputed.extend({ throttle: self.throttle });\n    }\n    if (!self.extFilter) {\n        grid.columns.subscribe(function (a) {\n            $.each(a, function (i, col) {\n                self.fieldMap[col.displayName().toLowerCase().replace(/\\s+/g, '')] = col.field;\n            });\n        });\n    }\n};\n","window.kg.SelectionService = function (grid) {\n    var self = this;\n    self.multi = grid.config.multiSelect;\n    self.selectedItems = grid.config.selectedItems;\n    self.selectedIndex = grid.config.selectedIndex;\n    self.lastClickedRow = undefined;\n    self.ignoreSelectedItemChanges = false; // flag to prevent circular event loops keeping single-select var in sync\n\n    self.rowFactory = {};\n\tself.Initialize = function (rowFactory) {\n        self.rowFactory = rowFactory;\n    };\n\t\t\n\t// function to manage the selection action of a data item (entity)\n\tself.ChangeSelection = function (rowItem, evt) {\n\t    grid.$$selectionPhase = true;\n\t    if (evt && evt.shiftKey && self.multi) {\n\t        if (self.lastClickedRow) {\n\t            var thisIndx = grid.filteredData.indexOf(rowItem.entity);\n\t            var prevIndx = grid.filteredData.indexOf(self.lastClickedRow.entity);\n\t            if (thisIndx == prevIndx) {\n\t                return false;\n\t            }\n\t            prevIndx++;\n\t            if (thisIndx < prevIndx) {\n\t                thisIndx = thisIndx ^ prevIndx;\n\t                prevIndx = thisIndx ^ prevIndx;\n\t                thisIndx = thisIndx ^ prevIndx;\n\t            }\n\t            var rows = [];\n\t            for (; prevIndx <= thisIndx; prevIndx++) {\n\t                rows.push(self.rowFactory.rowCache[prevIndx]);\n\t            }\n\t            if (rows[rows.length - 1].beforeSelectionChange(rows, evt)) {\n\t                $.each(rows, function(i, ri) {\n\t                    ri.selected(true);\n\t                    ri.entity[SELECTED_PROP] = true;\n\t                    if (self.selectedItems.indexOf(ri.entity) === -1) {\n\t                        self.selectedItems.push(ri.entity);\n\t                    }\n\t                });\n\t                rows[rows.length - 1].afterSelectionChange(rows, evt);\n\t            }\n\t            self.lastClickedRow = rows[rows.length - 1];\n\t            return true;\n\t        }\n\t    } else if (!self.multi) {\n\t        if (self.lastClickedRow && self.lastClickedRow != rowItem) {\n\t            self.setSelection(self.lastClickedRow, false);\n\t        }\n\t        self.setSelection(rowItem, grid.config.keepLastSelected ? true : !rowItem.selected());\n\t    } else {\n\t        self.setSelection(rowItem, !rowItem.selected());\n\t    }\n\t    self.lastClickedRow = rowItem;\n\t    grid.$$selectionPhase = false;\n        return true;\n    };\n\n    // just call this func and hand it the rowItem you want to select (or de-select)    \n    self.setSelection = function(rowItem, isSelected) {\n        rowItem.selected(isSelected) ;\n        rowItem.entity[SELECTED_PROP] = isSelected;\n        if (!isSelected) {\n            var indx = self.selectedItems.indexOf(rowItem.entity);\n            self.selectedItems.splice(indx, 1);\n        } else {\n            if (self.selectedItems.indexOf(rowItem.entity) === -1) {\n                self.selectedItems.push(rowItem.entity);\n            }\n        }\n    };\n    \n    // @return - boolean indicating if all items are selected or not\n    // @val - boolean indicating whether to select all/de-select all\n    self.toggleSelectAll = function (checkAll) {\n        var selectedlength = self.selectedItems().length;\n        if (selectedlength > 0) {\n            self.selectedItems.splice(0, selectedlength);\n        }\n        $.each(grid.filteredData(), function (i, item) {\n            item[SELECTED_PROP] = checkAll;\n            if (checkAll) {\n                self.selectedItems.push(item);\n            }\n        });\n        $.each(self.rowFactory.rowCache, function (i, row) {\n            if (row && row.selected) {\n                row.selected(checkAll);\n            }\n        });\n    };\n};","window.kg.sortService = {\n    colSortFnCache: {}, // cache of sorting functions. Once we create them, we don't want to keep re-doing it\n    dateRE: /^(\\d\\d?)[\\/\\.-](\\d\\d?)[\\/\\.-]((\\d\\d)?\\d\\d)$/, // nasty regex for date parsing\n    guessSortFn: function(item) {\n        var sortFn, // sorting function that is guessed\n            itemType, // the typeof item\n            dateParts, // for date parsing\n            month, // for date parsing\n            day; // for date parsing\n\n        if (item === undefined || item === null || item === '') {\n            return null;\n        }\n        itemType = typeof(item);\n        //check for numbers and booleans\n        switch (itemType) {\n            case \"number\":\n                sortFn = window.kg.sortService.sortNumber;\n                break;\n            case \"boolean\":\n                sortFn = window.kg.sortService.sortBool;\n                break;\n            default:\n                sortFn = undefined;\n                break;\n        }\n        //if we found one, return it\n        if (sortFn) {\n            return sortFn;\n        }\n        //check if the item is a valid Date\n        if (Object.prototype.toString.call(item) === '[object Date]') {\n            return window.kg.sortService.sortDate;\n        }\n        // if we aren't left with a string, return a basic sorting function...\n        if (itemType !== \"string\") {\n            return window.kg.sortService.basicSort;\n        }\n        // now lets string check..\n        //check if the item data is a valid number\n        if (item.match(/^-?[£$¤]?[\\d,.]+%?$/)) {\n            return window.kg.sortService.sortNumberStr;\n        }\n        // check for a date: dd/mm/yyyy or dd/mm/yy\n        // can have / or . or - as separator\n        // can be mm/dd as well\n        dateParts = item.match(window.kg.sortService.dateRE);\n        if (dateParts) {\n            // looks like a date\n            month = parseInt(dateParts[1], 10);\n            day = parseInt(dateParts[2], 10);\n            if (month > 12) {\n                // definitely dd/mm\n                return window.kg.sortService.sortDDMMStr;\n            } else if (day > 12) {\n                return window.kg.sortService.sortMMDDStr;\n            } else {\n                // looks like a date, but we can't tell which, so assume that it's MM/DD\n                return window.kg.sortService.sortMMDDStr;\n            }\n        }\n        //finally just sort the normal string...\n        return window.kg.sortService.sortAlpha;\n    },\n    basicSort: function(a, b) {\n        if (a == b) {\n            return 0;\n        }\n        if (a < b) {\n            return -1;\n        }\n        return 1;\n    },\n    sortNumber: function(a, b) {\n        return a - b;\n    },\n    sortNumberStr: function(a, b) {\n        var numA,\n            numB,\n            badA = false,\n            badB = false;\n        numA = parseFloat(a.replace(/[^0-9.-]/g, ''));\n        if (isNaN(numA)) {\n            badA = true;\n        }\n        numB = parseFloat(b.replace(/[^0-9.-]/g, ''));\n        if (isNaN(numB)) {\n            badB = true;\n        }\n        // we want bad ones to get pushed to the bottom... which effectively is \"greater than\"\n        if (badA && badB) {\n            return 0;\n        }\n        if (badA) {\n            return 1;\n        }\n        if (badB) {\n            return -1;\n        }\n        return numA - numB;\n    },\n    sortAlpha: function(a, b) {\n        var strA = a.toLowerCase(),\n            strB = b.toLowerCase();\n        return strA == strB ? 0 : (strA < strB ? -1 : 1);\n    },\n    sortBool: function(a, b) {\n        if (a && b) {\n            return 0;\n        }\n        if (!a && !b) {\n            return 0;\n        } else {\n            return a ? 1 : -1;\n        }\n    },\n    sortDate: function(a, b) {\n        var timeA = a.getTime(),\n            timeB = b.getTime();\n        return timeA == timeB ? 0 : (timeA < timeB ? -1 : 1);\n    },\n    sortDDMMStr: function(a, b) {\n        var dateA, dateB, mtch, m, d, y;\n        mtch = a.match(window.kg.sortService.dateRE);\n        y = mtch[3];\n        m = mtch[2];\n        d = mtch[1];\n        if (m.length == 1) {\n            m = '0' + m;\n        }\n        if (d.length == 1) {\n            d = '0' + d;\n        }\n        dateA = y + m + d;\n        mtch = b.match(window.kg.sortService.dateRE);\n        y = mtch[3];\n        m = mtch[2];\n        d = mtch[1];\n        if (m.length == 1) {\n            m = '0' + m;\n        }\n        if (d.length == 1) {\n            d = '0' + d;\n        }\n        dateB = y + m + d;\n        if (dateA == dateB) {\n            return 0;\n        }\n        if (dateA < dateB) {\n            return -1;\n        }\n        return 1;\n    },\n    sortMMDDStr: function(a, b) {\n        var dateA, dateB, mtch, m, d, y;\n        mtch = a.match(window.kg.sortService.dateRE);\n        y = mtch[3];\n        d = mtch[2];\n        m = mtch[1];\n        if (m.length == 1) {\n            m = '0' + m;\n        }\n        if (d.length == 1) {\n            d = '0' + d;\n        }\n        dateA = y + m + d;\n        mtch = b.match(window.kg.sortService.dateRE);\n        y = mtch[3];\n        d = mtch[2];\n        m = mtch[1];\n        if (m.length == 1) {\n            m = '0' + m;\n        }\n        if (d.length == 1) {\n            d = '0' + d;\n        }\n        dateB = y + m + d;\n        if (dateA == dateB) {\n            return 0;\n        }\n        if (dateA < dateB) {\n            return -1;\n        }\n        return 1;\n    },\n    sortData: function (data /*datasource*/, sortInfo) {\n        var unwrappedData = data();\n        // first make sure we are even supposed to do work\n        if (!unwrappedData || !sortInfo) {\n            return;\n        }\n        // grab the metadata for the rest of the logic\n        var col = sortInfo.column,\n            direction = sortInfo.direction,\n            sortFn,\n            item;\n        //see if we already figured out what to use to sort the column\n        if (window.kg.sortService.colSortFnCache[col.field]) {\n            sortFn = window.kg.sortService.colSortFnCache[col.field];\n        } else if (col.sortingAlgorithm != undefined) {\n            sortFn = col.sortingAlgorithm;\n            window.kg.sortService.colSortFnCache[col.field] = col.sortingAlgorithm;\n        } else { // try and guess what sort function to use\n            item = unwrappedData[0];\n            if (!item) {\n                return;\n            }\n            sortFn = kg.sortService.guessSortFn(item[col.field]);\n            //cache it\n            if (sortFn) {\n                window.kg.sortService.colSortFnCache[col.field] = sortFn;\n            } else {\n                // we assign the alpha sort because anything that is null/undefined will never get passed to\n                // the actual sorting function. It will get caught in our null check and returned to be sorted\n                // down to the bottom\n                sortFn = window.kg.sortService.sortAlpha;\n            }\n        }\n        //now actually sort the data\n        unwrappedData.sort(function (itemA, itemB) {\n            var propA = window.kg.utils.evalProperty(itemA, col.field);\n            var propB = window.kg.utils.evalProperty(itemB, col.field);\n            // we want to force nulls and such to the bottom when we sort... which effectively is \"greater than\"\n            if (!propB && !propA) {\n                return 0;\n            } else if (!propA) {\n                return 1;\n            } else if (!propB) {\n                return -1;\n            }\n            //made it this far, we don't have to worry about null & undefined\n            if (direction === ASC) {\n                return sortFn(propA, propB);\n            } else {\n                return 0 - sortFn(propA, propB);\n            }\n        });\n        data(unwrappedData);\n    },\n    Sort: function (sortInfo, data) {\n        if (window.kg.sortService.isSorting) {\n            return;\n        }\n        window.kg.sortService.isSorting = true;\n        window.kg.sortService.sortData(data, sortInfo);\n        window.kg.sortService.isSorting = false;\n    }\n};\n","window.kg.StyleProvider = function (grid) {\n    grid.canvasStyle = ko.computed(function() {\n        return { \"height\": grid.maxCanvasHt().toString() + \"px\" };\n    });\n    grid.headerScrollerStyle = ko.computed(function() {\n        return { \"height\": grid.config.headerRowHeight + \"px\" };\n    });\n    grid.topPanelStyle = ko.computed(function() {\n        return { \"width\": grid.rootDim.outerWidth() + \"px\", \"height\": grid.topPanelHeight() + \"px\" };\n    });\n    grid.headerStyle = ko.computed(function() {\n        return { \"width\": Math.max(0, grid.rootDim.outerWidth() - window.kg.domUtilityService.ScrollW) + \"px\", \"height\": grid.config.headerRowHeight + \"px\" };\n    });\n    grid.viewportStyle = ko.computed(function() {\n        return { \"width\": grid.rootDim.outerWidth() + \"px\", \"height\": grid.viewportDimHeight() + \"px\" };\n    });\n\tgrid.footerStyle = ko.computed(function () {\n        return { \"width\": grid.rootDim.outerWidth() + \"px\", \"height\": grid.config.footerRowHeight + \"px\" };\n    });\n};","/*! KoGrid v2.1.5 | MIT License */\n(function(window) {\n'use strict';\n\nif (!window.kg) {\n    window.kg = {};\n}\nwindow.kg.numberOfGrids = 0;\nwindow.kg.eventStorage = {};\n\nvar SELECTED_PROP = '__kg_selected__',\n    GRID_KEY = '__koGrid__',\n    // the # of rows we want to add to the top and bottom of the rendered grid rows\n    EXCESS_ROWS = 8,\n    SCROLL_THRESHOLD = 6,\n    ASC = \"asc\", // constant for sorting direction\n    DESC = \"desc\", // constant for sorting direction\n    KG_FIELD = '_kg_field_',\n    KG_DEPTH = '_kg_depth_',\n    KG_HIDDEN = '_kg_hidden_',\n    KG_COLUMN = '_kg_column_',\n    TEMPLATE_REGEXP = /<.+>/;\n\n//set event binding on the grid so we can select using the up/down keys\nwindow.kg.moveSelectionHandler = function(grid, evt) {\n    // null checks\n    if (window.kg.utils.isNullOrUndefined(grid) || window.kg.utils.isNullOrUndefined(grid.config.selectedItems)) {\n        return true;\n    }\n    var charCode = evt.which || evt.keyCode,\n        // detect which direction for arrow keys to navigate the grid\n        offset = (charCode === 38 ? -1 : (charCode === 40 ? 1 : null));\n    if (!offset) {\n        return true;\n    }\n    var items = grid.renderedRows(),\n        index = items.indexOf(grid.selectionService.lastClickedRow) + offset;\n    if (index < 0 || index >= items.length) {\n        return true;\n    }\ngrid.selectionService.ChangeSelection(items[index], evt);\n    if (index > items.length - EXCESS_ROWS) {\n        grid.$viewport.scrollTop(grid.$viewport.scrollTop() + (grid.config.rowHeight * EXCESS_ROWS));\n    } else if (index < EXCESS_ROWS) {\n        grid.$viewport.scrollTop(grid.$viewport.scrollTop() - (grid.config.rowHeight * EXCESS_ROWS));\n    }\n    return false;\n};\n\nif (!String.prototype.trim) {\n    String.prototype.trim = function() {\n        return this.replace(/^\\s+|\\s+$/g, '');\n    };\n}\nif (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function(elt /*, from*/) {\n        var len = this.length >>> 0;\n        var from = Number(arguments[1]) || 0;\n        from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n        if (from < 0) {\n            from += len;\n        }\n        for (; from < len; from++) {\n            if (from in this && this[from] === elt) {\n                return from;\n            }\n        }\n        return -1;\n    };\n}\nif (!Array.prototype.filter) {\n    Array.prototype.filter = function(fun /*, thisp */) {\n        \"use strict\";\n        var t = Object(this),\n            len = t.length >>> 0;\n        if (typeof fun !== \"function\") {\n            throw new TypeError();\n        }\n        var res = [];\n        var thisp = arguments[1];\n        for (var i = 0; i < len; i++) {\n            if (i in t) {\n                var val = t[i]; // in case fun mutates this\n                if (fun.call(thisp, val, i, t)) {\n                    res.push(val);\n                }\n            }\n        }\n        return res;\n    };\n}\nwindow.kg.utils = {\n    visualLength: function(node) {\n        var elem = document.getElementById('testDataLength');\n        if (!elem) {\n            elem = document.createElement('SPAN');\n            elem.id = \"testDataLength\";\n            elem.style.visibility = \"hidden\";\n            document.body.appendChild(elem);\n        }\n        $(elem).css('font', $(node).css('font'));\n        elem.innerHTML = $(node).text();\n        return elem.offsetWidth;\n    },\n    forIn: function(obj, action) {\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                action(obj[prop], prop);\n            }\n        }\n    },\n    evalProperty: function(entity, path) {\n        var e = ko.utils.unwrapObservable(entity);\n        var propPath = path.split('.'), i = 0;\n        var tempProp = ko.utils.unwrapObservable(e[propPath[i]]), links = propPath.length;\n        i++;\n        while (tempProp && i < links) {\n            tempProp = ko.utils.unwrapObservable(tempProp[propPath[i]]);\n            i++;\n        }\n        return tempProp;\n    },\n    endsWith: function(str, suffix) {\n        if (!str || !suffix || typeof str != \"string\") {\n            return false;\n        }\n        return str.indexOf(suffix, str.length - suffix.length) !== -1;\n    },\n    isNullOrUndefined: function(obj) {\n        if (obj === undefined || obj === null) {\n            return true;\n        }\n        return false;\n    },\n    getElementsByClassName: function(cl) {\n        var retnode = [];\n        var myclass = new RegExp('\\\\b' + cl + '\\\\b');\n        var elem = document.getElementsByTagName('*');\n        for (var i = 0; i < elem.length; i++) {\n            var classes = elem[i].className;\n            if (myclass.test(classes)) {\n                retnode.push(elem[i]);\n            }\n        }\n        return retnode;\n    },\n    getTemplatePromise: function(path) {\n        return $.ajax(path);\n    },\n    newId: (function() {\n        var seedId = new Date().getTime();\n        return function() {\n            return seedId += 1;\n        };\n    })(),\n\n    // we copy KO's ie detection here bc it isn't exported in the min versions of KO\n    // Detect IE versions for workarounds (uses IE conditionals, not UA string, for robustness)\n    ieVersion: (function() {\n        var version = 3, div = document.createElement('div'), iElems = div.getElementsByTagName('i');\n        // Keep constructing conditional HTML blocks until we hit one that resolves to an empty fragment\n        while (div.innerHTML = '<!--[if gt IE ' + (++version) + ']><i></i><![endif]-->',\n        iElems[0]) ;\n        return version > 4 ? version : undefined;\n    })()\n};\n\n$.extend(window.kg.utils, {\n    isIe6: (function() {\n        return window.kg.utils.ieVersion === 6;\n    })(),\n    isIe7: (function() {\n        return window.kg.utils.ieVersion === 7;\n    })(),\n    isIe: (function() {\n        return window.kg.utils.ieVersion !== undefined;\n    })()\n});\n\nwindow.kg.aggregateTemplate = function() { return '<div data-bind=\"click: toggleExpand, style: {\\'left\\': offsetLeft()}\" class=\"kgAggregate\"><span class=\"kgAggregateText\" data-bind=\"html: $data.label\">(<span data-bind=\"html: totalChildren\"></span> Items)</span><div data-bind=\"attr: {\\'class\\' : aggClass }\"></div></div>'; };\n\nwindow.kg.defaultCellTemplate = function() { return '<div data-bind=\"attr: { \\'class\\': \\'kgCellText colt\\' + $index()}, html: $data.getProperty($parent)\"></div>'; };\n\nwindow.kg.defaultGridTemplate = function() { return '<div data-bind=\"css: {\\'ui-widget\\': jqueryUITheme, \\'kgNoSelect\\' : disableTextSelection}\"><div class=\"kgTopPanel\" data-bind=\"css: {\\'ui-widget-header\\':jqueryUITheme, \\'ui-corner-top\\': jqueryUITheme}, style: $data.topPanelStyle\"><div class=\"kgGroupPanel\" data-bind=\"visible: $data.showGroupPanel, style: headerStyle\"><div class=\"kgGroupPanelDescription\" data-bind=\"visible: configGroups().length == 0\">Drag a column header here and drop it to group by that column</div><ul data-bind=\"visible: configGroups().length > 0, foreach: configGroups\" class=\"kgGroupList\"><li class=\"kgGroupItem\"><span class=\"kgGroupElement\"><div class=\"kgGroupName\"><span data-bind=\"text: displayName\"></span> <span data-bind=\"click: function(data) { $root.removeGroup($index()) }\" class=\"kgRemoveGroup\">x</span></div><span data-bind=\"visible: $index() < ($root.configGroups().length - 1)\" class=\"kgGroupArrow\"></span></span></li></ul></div><div class=\"kgHeaderContainer\" data-bind=\"style: headerStyle\"><div class=\"kgHeaderScroller\" data-bind=\"style: headerScrollerStyle, kgHeaderRow: $data\"></div></div><div class=\"kgHeaderButton\" data-bind=\"visible: ($data.showColumnMenu || $data.showFilter), click: toggleShowMenu\"><div class=\"kgHeaderButtonArrow\"></div></div><div data-bind=\"visible: showMenu\" class=\"kgColMenu\"><div data-bind=\"visible: showFilter\"><input placeholder=\"Search Field:Value\" type=\"text\" data-bind=\"value: filterText, valueUpdate: \\'afterkeydown\\'\"></div><div data-bind=\"visible: showColumnMenu\"><span class=\"kgMenuText\">Choose Columns:</span><ul class=\"kgColList\" data-bind=\"foreach: nonAggColumns\"><li class=\"kgColListItem\"><label style=\"position: relative\"><input type=\"checkbox\" class=\"kgColListCheckbox\" data-bind=\"checked: visible\"> <span data-bind=\"text: displayName, click: toggleVisible\"></span> <a title=\"Group By\" data-bind=\"attr: {\\'class\\': groupedByClass }, visible: (field != \\'\\\\u2714\\'), click: $parent.groupBy\"></a> <span class=\"kgGroupingNumber\" data-bind=\"visible: groupIndex() > 0, text: groupIndex\"></span></label></li></ul></div></div></div><div class=\"kgViewport\" data-bind=\"css: {\\'ui-widget-content\\': jqueryUITheme}, style: viewportStyle\"><div class=\"kgCanvas\" data-bind=\"style: canvasStyle\"><div data-bind=\"foreach: renderedRows\" style=\"position: absolute\"><div data-bind=\"style: { \\'top\\': offsetTop, \\'height\\': $parent.rowHeight + \\'px\\' }, click: toggleSelected, css: {\\'selected\\': selected, \\'even\\': isEven , \\'odd\\': isOdd, \\'ui-state-default\\': $parent.jqueryUITheme && isOdd, \\'ui-state-active\\':$parent.jqueryUITheme && isEven}, kgRow: $data\" class=\"kgRow\"></div></div></div></div><div class=\"kgFooterPanel\" data-bind=\"css: {\\'ui-widget-content\\': jqueryUITheme, \\'ui-corner-bottom\\': jqueryUITheme}, style: footerStyle\"><div class=\"kgTotalSelectContainer\" data-bind=\"visible: footerVisible\"><div class=\"kgFooterTotalItems\" data-bind=\"css: {\\'kgNoMultiSelect\\': !multiSelect}\"><span class=\"kgLabel\">Total Items: <span data-bind=\"text: maxRowsDisplay\"></span></span><span data-bind=\"visible: filterText().length > 0\" class=\"kgLabel\">(Showing: <span data-bind=\"text: totalFilteredItemsLength\"></span>)</span></div><div class=\"kgFooterSelectedItems\" data-bind=\"visible: multiSelect\"><span class=\"kgLabel\">Selected Items: <span data-bind=\"text: selectedItemCount\"></span></span></div></div><div class=\"kgPagerContainer\" style=\"float: right; margin-top: 10px\" data-bind=\"visible: (footerVisible && enablePaging), css: {\\'kgNoMultiSelect\\': !multiSelect}\"><div style=\"float:left; margin-right: 10px\" class=\"kgRowCountPicker\"><span style=\"float: left; margin-top: 3px\" class=\"kgLabel\">Page Size:</span><select style=\"float: left;height: 27px; width: 100px\" data-bind=\"value: pagingOptions.pageSize, options: pagingOptions.pageSizes\"></select></div><div style=\"float:left; margin-right: 10px; line-height:25px\" class=\"kgPagerControl\" style=\"float: left; min-width: 135px\"><button class=\"kgPagerButton\" data-bind=\"click: pageToFirst, disable: cantPageBackward()\" title=\"First Page\"><div class=\"kgPagerFirstTriangle\"><div class=\"kgPagerFirstBar\"></div></div></button> <button class=\"kgPagerButton\" data-bind=\"click: pageBackward, disable: cantPageBackward()\" title=\"Previous Page\"><div class=\"kgPagerFirstTriangle kgPagerPrevTriangle\"></div></button> <input class=\"kgPagerCurrent\" type=\"number\" style=\"width:50px; height: 24px; margin-top: 1px; padding: 0px 4px\" data-bind=\"value: pagingOptions.currentPage, valueUpdate: \\'afterkeydown\\'\"> <button class=\"kgPagerButton\" data-bind=\"click: pageForward, disable: cantPageForward()\" title=\"Next Page\"><div class=\"kgPagerLastTriangle kgPagerNextTriangle\"></div></button> <button class=\"kgPagerButton\" data-bind=\"click: pageToLast, disable: cantPageForward()\" title=\"Last Page\"><div class=\"kgPagerLastTriangle\"><div class=\"kgPagerLastBar\"></div></div></button></div></div></div></div>'; };\n\nwindow.kg.defaultHeaderCellTemplate = function() { return '<div data-bind=\"style: { cursor : sortable() ? \\'pointer\\' : \\'default\\' }, click: sort, css: {\\'kgSorted\\': !noSortVisible }, attr: {\\'class\\': \\'kgHeaderSortColumn \\' + headerClass()}\"><div data-bind=\"attr: { \\'class\\': \\'colt\\' + $index() + \\' kgHeaderText\\' }, html: displayName\"></div><div class=\"kgSortButtonDown\" data-bind=\"visible: showSortButtonDown\"></div><div class=\"kgSortButtonUp\" data-bind=\"visible: showSortButtonUp\"></div><div data-bind=\"visible: resizable, click: gripClick, mouseEvents: { mouseDown: gripOnMouseDown }\" class=\"kgHeaderGrip\"></div></div>'; };\n\nwindow.kg.defaultHeaderRowTemplate = function() { return '<div data-bind=\"foreach: visibleColumns\"><div data-bind=\"kgHeaderCell: $data, attr: { \\'class\\': \\'kgHeaderCell col\\' + $index() }\"></div></div>'; };\n\nwindow.kg.defaultRowTemplate = function() { return '<div data-bind=\"style: { cursor : canSelectRows ? \\'pointer\\' : \\'default\\' }, foreach: $grid.visibleColumns, css: { \\'ui-widget-content\\': $grid.jqueryUITheme }\"><div data-bind=\"attr: { \\'class\\': cellClass() + \\' kgCell col\\' + $index() }, kgCell: $data\"></div></div>'; };\n\nko.bindingHandlers['kgCell'] = (function () {\n    return {\n        'init': function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n            bindingContext.$userViewModel = bindingContext.$parent.$userViewModel;\n            var compile = function (html) {\n                var cell = $(html);\n                ko.applyBindings(bindingContext, cell[0]);\n                $(element).html(cell);\n            };\n            if (viewModel.cellTemplate.then) {\n                viewModel.cellTemplate.then(function(p) {\n                    compile(p);\n                });\n            } else {\n                compile(viewModel.cellTemplate);\n            }\n            return { controlsDescendantBindings: true };\n        }\n    };\n}());\n\nko.bindingHandlers['kgHeaderCell'] = (function () {\n    return {\n        'init': function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n            var newContext = bindingContext.extend({ $grid: bindingContext.$parent, $userViewModel: bindingContext.$parent.$userViewModel });\n            var compile = function (html) {\n                var headerCell = $(html);\n                ko.applyBindings(newContext, headerCell[0]);\n                $(element).html(headerCell);\n            };\n            if (viewModel.headerCellTemplate.then) {\n                viewModel.headerCellTemplate.then(function (p) {\n                    compile(p);\n                });\n            } else {\n                compile(viewModel.headerCellTemplate);\n            }\n            return { controlsDescendantBindings: true };\n        }\n    };\n}());\nko.bindingHandlers['kgHeaderRow'] = (function () {\n    return {\n        'init': function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n            bindingContext.$userViewModel = bindingContext.$data.$userViewModel;\n            var compile = function(html) {\n                var headerRow = $(html);\n                ko.applyBindings(bindingContext, headerRow[0]);\n                $(element).html(headerRow);\n            };\n            if (viewModel.headerRowTemplate.then) {\n                viewModel.headerRowTemplate.then(function (p) {\n                    compile(p);\n                });\n            } else {\n                compile(viewModel.headerRowTemplate);\n            }\n            return { controlsDescendantBindings: true };\n        }\n    };\n}());\nko.bindingHandlers['mouseEvents'] = (function () {\n    return {\n        'init': function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n            var eFuncs = valueAccessor();\n            if (eFuncs.mouseDown) {\n                $(element).mousedown(eFuncs.mouseDown);\n            }\n        }\n    };\n}());\nko.bindingHandlers['kgRow'] = (function () {\n    return {\n        'init': function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n            var row = valueAccessor();\n            var grid = row.$grid = bindingContext.$parent;\n            var source;\n            if (row.isAggRow) {\n                source = window.kg.aggregateTemplate();\n            } else {\n                source = grid.rowTemplate;\n            }\n            var compile = function(html) {\n                var rowElem = $(html);\n                row.$userViewModel = bindingContext.$parent.$userViewModel;\n                ko.applyBindings(row, rowElem[0]);\n                $(element).html(rowElem);\n            };\n            if (source.then) {\n                source.then(function (p) {\n                    compile(p);\n                });\n            } else {\n                compile(source);\n            }\n            return { controlsDescendantBindings: true };\n        }\n    };\n}());\n\nko.bindingHandlers['koGrid'] = (function () {\n    return {\n        'init': function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n            var options = valueAccessor();\n            var elem = $(element);\n            options.gridDim = new window.kg.Dimension({ outerHeight: ko.observable(elem.height()), outerWidth: ko.observable(elem.width()) });\n            var grid = new window.kg.Grid(options);\n            var gridElem = $(window.kg.defaultGridTemplate());\n            // if it is a string we can watch for data changes. otherwise you won't be able to update the grid data\n            options.data.subscribe(function () {\n                if (grid.$$selectionPhase) {\n                    return;\n                }\n                grid.searchProvider.evalFilter();\n                grid.refreshDomSizes();\n            });\n            // if columndefs are observable watch for changes and rebuild columns.\n            if (ko.isObservable(options.columnDefs)) {\n                options.columnDefs.subscribe(function (newDefs) {\n                    grid.columns([]);\n                    grid.config.columnDefs = newDefs;\n                    grid.buildColumns();\n                    grid.configureColumnWidths();\n                });\n            }\n            //set the right styling on the container\n            elem.addClass(\"koGrid\").addClass(grid.gridId.toString());\n            elem.append(gridElem);\n            grid.$userViewModel = bindingContext.$data;\n            ko.applyBindings(grid, gridElem[0]);\n            //walk the element's graph and the correct properties on the grid\n            window.kg.domUtilityService.AssignGridContainers(elem, grid);\n            grid.configureColumnWidths();\n            grid.refreshDomSizes();\n            //now use the manager to assign the event handlers\n            grid.eventProvider = new window.kg.EventProvider(grid);\n            //initialize plugins.\n            $.each(grid.config.plugins, function (i, p) {\n                if (typeof p.onGridInit === 'function') {\n                    p.onGridInit(grid);\n                }\n            });\n            window.kg.domUtilityService.BuildStyles(grid);\n            return { controlsDescendantBindings: true };\n        }\n    };\n}());\nwindow.kg.Aggregate = function (aggEntity, rowFactory) {\n    var self = this;\n    self.index = 0;\n    self.offsetTop = ko.observable(0);\n    self.entity = aggEntity;\n    self.label = ko.observable(aggEntity.gLabel);\n    self.field = aggEntity.gField;\n    self.depth = aggEntity.gDepth;\n    self.parent = aggEntity.parent;\n    self.children = aggEntity.children;\n    self.aggChildren = aggEntity.aggChildren;\n    self.aggIndex = aggEntity.aggIndex;\n    self.collapsed = ko.observable(true);\n    self.isAggRow = true;\n    self.offsetLeft = ko.observable((aggEntity.gDepth * 25).toString() + 'px');\n    self.aggLabelFilter = aggEntity.aggLabelFilter;\n    self.toggleExpand = function() {\n        var c = self.collapsed();\n        self.collapsed(!c);\n        self.notifyChildren();\n    };\n    self.setExpand = function (state) {\n        self.collapsed(state);\n        self.notifyChildren();\n    };\n    self.notifyChildren = function() {\n        $.each(self.aggChildren, function (i, child) {\n            child.entity[KG_HIDDEN] = self.collapsed();\n            if (self.collapsed()) {\n                var c = self.collapsed();\n                child.setExpand(c);\n            }\n        });\n        $.each(self.children, function (i, child) {\n            child[KG_HIDDEN] = self.collapsed();\n        });\n        rowFactory.rowCache = [];\n        var foundMyself = false;\n        $.each(rowFactory.aggCache, function (i, agg) {\n            if (foundMyself) {\n                var offset = (30 * self.children.length);\n                var c = self.collapsed();\n                agg.offsetTop(c ? agg.offsetTop() - offset : agg.offsetTop() + offset);\n            } else {\n                if (i == self.aggIndex) {\n                    foundMyself = true;\n                }\n            }\n        });\n        rowFactory.renderedChange();\n    };\n    self.aggClass = ko.computed(function() {\n        return self.collapsed() ? \"kgAggArrowCollapsed\" : \"kgAggArrowExpanded\";\n    });\n    self.totalChildren = ko.computed(function() {\n        if (self.aggChildren.length > 0) {\n            var i = 0;\n            var recurse = function (cur) {\n                if (cur.aggChildren.length > 0) {\n                    $.each(cur.aggChildren, function (x, a) {\n                        recurse(a);\n                    });\n                } else {\n                    i += cur.children.length;\n                }\n            };\n            recurse(self);\n            return i;\n        } else {\n            return self.children.length;\n        }\n    });\n    self.selected = ko.observable(false);\n    self.isEven = ko.observable(false);\n    self.isOdd = ko.observable(false);\n    self.toggleSelected = function () { return true; };\n};\n\nwindow.kg.Column = function (config, grid) {\n    var self = this,\n        colDef = config.colDef,\n\t\tdelay = 500,\n        clicks = 0,\n        timer = null;\n    self.eventTaget = undefined;\n    self.width = colDef.width;\n\tself.groupIndex = ko.observable(0);\n\tself.isGroupedBy = ko.observable(false);\n\tself.groupedByClass = ko.computed(function(){ return self.isGroupedBy() ? \"kgGroupedByIcon\": \"kgGroupIcon\";});\n\tself.sortable = ko.observable(false);\n\tself.resizable = ko.observable(false);\n    self.minWidth = !colDef.minWidth ? 50 : colDef.minWidth;\n    self.maxWidth = !colDef.maxWidth ? 9000 : colDef.maxWidth;\n    self.headerRowHeight = config.headerRowHeight;\n    self.displayName = ko.observable(colDef.displayName || colDef.field);\n    self.index = config.index;\n    self.isAggCol = config.isAggCol;\n    self.cellClass = ko.observable(colDef.cellClass || \"\");\n    self.cellFilter = colDef.cellFilter || colDef.cellFormatter;\n    self.field = colDef.field;\n    self.aggLabelFilter = colDef.cellFilter || colDef.cellFormatter || colDef.aggLabelFilter || colDef.aggLabelFormatter;\n    self._visible = ko.observable(window.kg.utils.isNullOrUndefined(colDef.visible) || colDef.visible);\n    self.visible = ko.computed({\n        read: function() {\n            return self._visible();\n        },\n        write: function(val) {\n            self.toggleVisible(val);\n        }\n    });\n    if (config.enableSort) {\n        self.sortable(window.kg.utils.isNullOrUndefined(colDef.sortable) || colDef.sortable);\n    }\n    if (config.enableResize) {\n        self.resizable(window.kg.utils.isNullOrUndefined(colDef.resizable) || colDef.resizable);\n    }\n    self.sortDirection = ko.observable(undefined);\n    self.sortingAlgorithm = colDef.sortFn;\n    self.headerClass = ko.observable(colDef.headerClass);\n    self.headerCellTemplate = colDef.headerCellTemplate || window.kg.defaultHeaderCellTemplate();\n    self.cellTemplate = colDef.cellTemplate || window.kg.defaultCellTemplate();\n    if (colDef.cellTemplate && !TEMPLATE_REGEXP.test(colDef.cellTemplate)) {\n        self.cellTemplate = window.kg.utils.getTemplatePromise(colDef.cellTemplate);\n    }\n    if (colDef.headerCellTemplate && !TEMPLATE_REGEXP.test(colDef.headerCellTemplate)) {\n        self.headerCellTemplate = window.kg.utils.getTemplatePromise(colDef.headerCellTemplate);\n    }\n    self.getProperty = function (row) {\n        var ret;\n        if (self.cellFilter) {\n            ret = self.cellFilter(row.getProperty(self.field));\n        } else {\n            ret = row.getProperty(self.field);\n        }\n        return ret;\n    };\n    self.toggleVisible = function (val) {\n        var v;\n        if (window.kg.utils.isNullOrUndefined(val) || typeof val == \"object\") {\n            v = !self._visible();\n        } else {\n            v = val;\n        }\n        self._visible(v);\n        window.kg.domUtilityService.BuildStyles(grid);\n    };\n\n    self.showSortButtonUp = ko.computed(function () {\n        return self.sortable ? self.sortDirection() === DESC : self.sortable;\n    });\n    self.showSortButtonDown = ko.computed(function () {\n        return self.sortable ? self.sortDirection() === ASC : self.sortable;\n    });     \n    self.noSortVisible = ko.computed(function () {\n        return !self.sortDirection();\n    });\n    self.sort = function () {\n        if (!self.sortable()) {\n            return true; // column sorting is disabled, do nothing\n        }\n        var dir = self.sortDirection() === ASC ? DESC : ASC;\n        self.sortDirection(dir);\n        config.sortCallback(self, dir);\n        return false;\n    };   \n    self.gripClick = function (data, event) {\n        event.stopPropagation();\n        clicks++;  //count clicks\n        if (clicks === 1) {\n            timer = setTimeout(function () {\n                //Here you can add a single click action.\n                clicks = 0;  //after action performed, reset counter\n            }, delay);\n        } else {\n            clearTimeout(timer);  //prevent single-click action\n            config.resizeOnDataCallback(self);  //perform double-click action\n            clicks = 0;  //after action performed, reset counter\n        }\n    };\n    self.gripOnMouseDown = function (event) {\n        event.stopPropagation();\n        if (event.ctrlKey) {\n            self.toggleVisible();\n            window.kg.domUtilityService.BuildStyles(grid);\n            grid.config.columnsChanged(grid.columns.peek());\n            return true;\n        }\n        self.eventTaget = event.target.parentElement;\n        self.eventTaget.style.cursor = 'col-resize';\n        self.startMousePosition = event.clientX;\n        self.origWidth = self.width;\n        $(document).mousemove(self.onMouseMove);\n        $(document).mouseup(self.gripOnMouseUp);\n        return false;\n    };\n    self.onMouseMove = function (event) {\n        event.stopPropagation();\n        var diff = event.clientX - self.startMousePosition;\n        var newWidth = diff + self.origWidth;\n        self.width = (newWidth < self.minWidth ? self.minWidth : (newWidth > self.maxWidth ? self.maxWidth : newWidth));\n        window.kg.domUtilityService.BuildStyles(grid);\n        return false;\n    };\n    self.gripOnMouseUp = function (event) {\n        event.stopPropagation();\n        $(document).off('mousemove');\n        $(document).off('mouseup');\n        self.eventTaget.style.cursor = self.sortable() ? 'pointer' : 'default';\n        self.eventTaget = undefined;\n        grid.config.columnsChanged(grid.columns.peek());\n        return false;\n    };\n};\nwindow.kg.Dimension = function (options) {\n    this.outerHeight = null;\n    this.outerWidth = null;\n    $.extend(this, options);\n};\nvar getWidths = function () {\n    var $testContainer = $('<div></div>');\n    $testContainer.appendTo('body');\n    // 1. Run all the following measurements on startup!\n    //measure Scroll Bars\n    $testContainer.height(100).width(100).css(\"position\", \"absolute\").css(\"overflow\", \"scroll\");\n    $testContainer.append('<div style=\"height: 400px; width: 400px;\"></div>');\n    window.kg.domUtilityService.ScrollH = ($testContainer.height() - $testContainer[0].clientHeight);\n    window.kg.domUtilityService.ScrollW = ($testContainer.width() - $testContainer[0].clientWidth);\n    $testContainer.empty();\n    //clear styles\n    $testContainer.attr('style', '');\n    //measure letter sizes using a pretty typical font size and fat font-family\n    $testContainer.append('<span style=\"font-family: Verdana, Helvetica, Sans-Serif; font-size: 14px;\"><strong>M</strong></span>');\n    window.kg.domUtilityService.LetterW = $testContainer.children().first().width();\n    $testContainer.remove();\n};\nwindow.kg.domUtilityService = {\n    AssignGridContainers: function (rootEl, grid) {\n        grid.$root = $(rootEl);\n        //Headers\n        grid.$topPanel = grid.$root.find(\".kgTopPanel\");\n        grid.$groupPanel = grid.$root.find(\".kgGroupPanel\");\n        grid.$headerContainer = grid.$topPanel.find(\".kgHeaderContainer\");\n        grid.$headerScroller = grid.$topPanel.find(\".kgHeaderScroller\");\n        grid.$headers = grid.$headerScroller.children();\n        //Viewport\n        grid.$viewport = grid.$root.find(\".kgViewport\");\n        //Canvas\n        grid.$canvas = grid.$viewport.find(\".kgCanvas\");\n        //Footers\n        grid.$footerPanel = grid.$root.find(\".ngFooterPanel\");\n        window.kg.domUtilityService.UpdateGridLayout(grid);\n    },\n    UpdateGridLayout: function(grid) {\n        //catch this so we can return the viewer to their original scroll after the resize!\n        var scrollTop = grid.$viewport.scrollTop();\n        grid.elementDims.rootMaxW = grid.$root.width();\n        grid.elementDims.rootMaxH = grid.$root.height();\n        //check to see if anything has changed\n        grid.refreshDomSizes();\n        grid.adjustScrollTop(scrollTop, true); //ensure that the user stays scrolled where they were\n    },\n    BuildStyles: function(grid) {\n        var rowHeight = grid.config.rowHeight,\n            $style = grid.$styleSheet,\n            gridId = grid.gridId,\n            css,\n            cols = grid.visibleColumns(),\n            sumWidth = 0;\n\n        if (!$style) {\n            $style = $('#' + gridId);\n            if (!$style[0]) {\n                $style = $(\"<style id='\" + gridId + \"' type='text/css' rel='stylesheet' />\");\n                $style.appendTo('body');\n            }\n        }\n        $style.empty();\n        var trw = grid.totalRowWidth();\n        css = \".\" + gridId + \" .kgCanvas { width: \" + trw + \"px; }\"+\n              \".\" + gridId + \" .kgRow { width: \" + trw + \"px; }\" +\n              \".\" + gridId + \" .kgCell { height: \" + rowHeight + \"px; }\"+\n              \".\" + gridId + \" .kgCanvas { width: \" + trw + \"px; }\" +\n              \".\" + gridId + \" .kgHeaderCell { top: 0; bottom: 0; }\" +\n              \".\" + gridId + \" .kgHeaderScroller { width: \" + (trw + window.kg.domUtilityService.scrollH + 2) + \"px}\";\n        $.each(cols, function (i, col) {\n            css += \".\" + gridId + \" .col\" + i + \" { width: \" + col.width + \"px; left: \" + sumWidth + \"px; right: \" + (trw - sumWidth - col.width) + \"px; height: \" + rowHeight + \"px }\" +\n                   \".\" + gridId + \" .colt\" + i + \" { width: \" + col.width + \"px; }\";\n            sumWidth += col.width;\n        });\n        if (window.kg.utils.isIe) { // IE\n            $style[0].styleSheet.cssText = css;\n        } else {\n            $style.append(document.createTextNode(css));\n        }\n        grid.$styleSheet = $style;\n    },\n    ScrollH: 17, // default in IE, Chrome, & most browsers\n    ScrollW: 17, // default in IE, Chrome, & most browsers\n    LetterW: 10\n};\ngetWidths();\n\nwindow.kg.EventProvider = function (grid) {\n    var self = this;\n    // The init method gets called during the ng-grid directive execution.\n    self.colToMove = undefined;\n\tself.groupToMove = undefined;\n    self.assignEvents = function () {\n        // Here we set the onmousedown event handler to the header container.\n\t\tif(grid.config.jqueryUIDraggable){\n\t\t\tgrid.$groupPanel.droppable({\n\t\t\t\taddClasses: false,\n\t\t\t\tdrop: function(event) {\n\t\t\t\t\tself.onGroupDrop(event);\n\t\t\t\t}\n\t\t\t});\n\t\t\t$(document).ready(self.setDraggables);\n\t\t} else {\n\t\t\tgrid.$groupPanel.on('mousedown', self.onGroupMouseDown).on('dragover', self.dragOver).on('drop', self.onGroupDrop);\n\t\t\tgrid.$headerScroller.on('mousedown', self.onHeaderMouseDown).on('dragover', self.dragOver).on('drop', self.onHeaderDrop);\n\t\t\tif (grid.config.enableRowReordering) {\n\t\t\t\tgrid.$viewport.on('mousedown', self.onRowMouseDown).on('dragover', self.dragOver).on('drop', self.onRowDrop);\n\t\t\t}\n\t\t\tself.setDraggables();\n\t\t}\n        grid.columns.subscribe(self.setDraggables);\n    };\n    self.dragOver = function(evt) {\n        evt.preventDefault();\n    };\n\n\t//For JQueryUI\n\tself.setDraggables = function(){\n\t\tif(!grid.config.jqueryUIDraggable){\n\t\t\tgrid.$root.find('.kgHeaderSortColumn').attr('draggable', 'true');\n\t\t\tif (navigator.userAgent.indexOf(\"MSIE\") != -1)\n\t\t\t{\n\t\t\t\t//call native IE dragDrop() to start dragging\n\t\t\t\tgrid.$root.find('.kgHeaderSortColumn').bind('selectstart', function () { this.dragDrop(); return false; });\n\t\t\t}\n\t\t} else {\n\t\t\tgrid.$root.find('.kgHeaderSortColumn').draggable({\n\t\t\t\thelper: 'clone',\n\t\t\t\tappendTo: 'body',\n\t\t\t\tstack: 'div',\n\t\t\t\taddClasses: false,\n\t\t\t\tstart: function(event){\n\t\t\t\t\tself.onHeaderMouseDown(event);\n\t\t\t\t}\n\t\t\t}).droppable({\n\t\t\t\tdrop: function(event) {\n\t\t\t\t\tself.onHeaderDrop(event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\n    self.onGroupMouseDown = function(event) {\n        var groupItem = $(event.target);\n        // Get the scope from the header container\n\t\tif(groupItem[0].className !='kgRemoveGroup'){\n\t\t    var groupItemScope = ko.dataFor(groupItem[0]);\n\t\t\tif (groupItemScope) {\n\t\t\t\t// set draggable events\n\t\t\t\tif(!grid.config.jqueryUIDraggable){\n\t\t\t\t\tgroupItem.attr('draggable', 'true');\n\t\t\t\t}\n\t\t\t\t// Save the column for later.\n\t\t\t\tself.groupToMove = { header: groupItem, groupName: groupItemScope, index: groupItemScope.groupIndex() - 1 };\n\t\t\t}\n\t\t} else {\n\t\t\tself.groupToMove = undefined;\n\t\t}\n    };\n\n    self.onGroupDrop = function(event) {\n        // clear out the colToMove object\n        var groupContainer;\n        var groupScope;\n        if (self.groupToMove) {\n            // Get the closest header to where we dropped\n            groupContainer = $(event.target).closest('.kgGroupElement'); // Get the scope from the header.\n            if (groupContainer.context.className =='kgGroupPanel') {\n                grid.configGroups.splice(self.groupToMove.index, 1);\n                grid.configGroups.push(self.groupToMove.groupName);\n            } else {\n                groupScope = ko.dataFor(groupContainer[0]);\n                if (groupScope) {\n                    // If we have the same column, do nothing.\n                    if (self.groupToMove.index != groupScope.groupIndex()) {\n\t\t\t\t\t\t// Splice the columns\n                        grid.configGroups.splice(self.groupToMove.index, 1);\n                        grid.configGroups.splice(groupScope.groupIndex(), 0, self.groupToMove.groupName);\n\t\t\t\t\t}\n                }\n            }\n\t\t\tself.groupToMove = undefined;\n\t\t\tgrid.fixGroupIndexes();\n        } else {\n\t\t\tif (grid.configGroups.indexOf(self.colToMove.col) == -1) {\n                groupContainer = $(event.target).closest('.kgGroupElement'); // Get the scope from the header.\n\t\t\t\tif (groupContainer.context.className =='kgGroupPanel' || groupContainer.context.className =='kgGroupPanelDescription') {\n\t\t\t\t    grid.groupBy(self.colToMove.col);\n\t\t\t\t} else {\n\t\t\t\t    groupScope = ko.dataFor(groupContainer[0]);\n\t\t\t\t    if (groupScope) {\n\t\t\t\t\t\t// Splice the columns\n\t\t\t\t        grid.removeGroup(groupScope.groupIndex());\n\t\t\t\t\t}\n\t\t\t\t}\n            }\n\t\t\tself.colToMove = undefined;\n        }\n    };\n\n    //Header functions\n    self.onHeaderMouseDown = function (event) {\n        // Get the closest header container from where we clicked.\n        var headerContainer = $(event.target).closest('.kgHeaderSortColumn');\n        if (!headerContainer[0]) {\n            return true;\n        }\n        // Get the scope from the header container\n\n        var headerScope = ko.dataFor(headerContainer[0]);\n        if (headerScope) {\n            // Save the column for later.\n            self.colToMove = { header: headerContainer, col: headerScope };\n        }\n        return true;\n    };\n\n    self.onHeaderDrop = function (event) {\n        if (!self.colToMove) {\n            return true;\n        }\n        // Get the closest header to where we dropped\n        var headerContainer = $(event.target).closest('.kgHeaderSortColumn');\n        if (!headerContainer[0]) {\n            return true;\n        }\n        // Get the scope from the header.\n        var headerScope = ko.dataFor(headerContainer[0]);\n        if (headerScope) {\n            // If we have the same column, do nothing.\n            if (self.colToMove.col == headerScope) {\n                return true;\n            }\n            // Splice the columns\n            var cols = grid.columns.peek();\n            cols.splice(self.colToMove.col.index, 1);\n            cols.splice(headerScope.index, 0, self.colToMove.col);\n            grid.fixColumnIndexes();\n            grid.columns(cols);\n            // Finally, rebuild the CSS styles.\n            window.kg.domUtilityService.BuildStyles(grid);\n            // clear out the colToMove object\n            self.colToMove = undefined;\n        }\n        return true;\n    };\n\n    // Row functions\n    self.onRowMouseDown = function (event) {\n        // Get the closest row element from where we clicked.\n        var targetRow = $(event.target).closest('.kgRow');\n        if (!targetRow[0]) {\n            return;\n        }\n        // Get the scope from the row element\n        var rowScope = ko.dataFor(targetRow[0]);\n        if (rowScope) {\n            // set draggable events\n            targetRow.attr('draggable', 'true');\n            // Save the row for later.\n            window.kg.eventStorage.rowToMove = { targetRow: targetRow, scope: rowScope };\n        }\n    };\n\n    self.onRowDrop = function (event) {\n        // Get the closest row to where we dropped\n        var targetRow = $(event.target).closest('.kgRow');\n        // Get the scope from the row element.\n        var rowScope = ko.dataFor(targetRow[0]);\n        if (rowScope) {\n            // If we have the same Row, do nothing.\n            var prevRow = window.kg.eventStorage.rowToMove;\n            if (prevRow.scope == rowScope) {\n                return;\n            }\n            // Splice the Rows via the actual datasource\n            var sd = grid.sortedData();\n            var i = sd.indexOf(prevRow.scope.entity);\n            var j = sd.indexOf(rowScope.entity);\n            grid.sortedData.splice(i, 1);\n            grid.sortedData.splice(j, 0, prevRow.scope.entity);\n            grid.searchProvider.evalFilter();\n            // clear out the rowToMove object\n            window.kg.eventStorage.rowToMove = undefined;\n            // if there isn't an apply already in progress lets start one\n        }\n    };\n    self.assignGridEventHandlers = function() {\n        grid.$viewport.scroll(function(e) {\n            var scrollLeft = e.target.scrollLeft,\n                scrollTop = e.target.scrollTop;\n            grid.adjustScrollLeft(scrollLeft);\n            grid.adjustScrollTop(scrollTop);\n        });\n        grid.$viewport.off('keydown');\n        grid.$viewport.on('keydown', function(e) {\n            return window.kg.moveSelectionHandler(grid, e);\n        });\n        //Chrome and firefox both need a tab index so the grid can recieve focus.\n        //need to give the grid a tabindex if it doesn't already have one so\n        //we'll just give it a tab index of the corresponding gridcache index\n        //that way we'll get the same result every time it is run.\n        //configurable within the options.\n        if (grid.config.tabIndex === -1) {\n            grid.$viewport.attr('tabIndex', window.kg.numberOfGrids);\n            window.kg.numberOfGrids++;\n        } else {\n            grid.$viewport.attr('tabIndex', grid.config.tabIndex);\n        }\n        $(window).resize(function() {\n            window.kg.domUtilityService.UpdateGridLayout(grid);\n            if (grid.config.maintainColumnRatios) {\n                grid.configureColumnWidths();\n            }\n        });\n    };\n    self.assignGridEventHandlers();\n    // In this example we want to assign grid events.\n    self.assignEvents();\n};\n\nwindow.kg.Grid = function (options) {\n    var defaults = {\n            rowHeight: 30,\n            columnWidth: 100,\n            headerRowHeight: 30,\n            footerRowHeight: 55,\n            footerVisible: true,\n            displayFooter: undefined,\n            canSelectRows: true,\n            selectAllState: ko.observable(false),\n            data: ko.observableArray([]),\n            columnDefs: undefined,\n            selectedItems: ko.observableArray([]), // array, if multi turned off will have only one item in array\n            displaySelectionCheckbox: true, //toggles whether row selection check boxes appear\n            selectWithCheckboxOnly: false,\n            useExternalSorting: false,\n            sortInfo: ko.observable(undefined), // similar to filterInfo\n            multiSelect: true,\n            tabIndex: -1,\n            enableColumnResize: true,\n            enableSorting: true,\n            maintainColumnRatios: undefined,\n            beforeSelectionChange: function () { return true;},\n            afterSelectionChange: function () { },\n            columnsChanged: function() { },\n            rowTemplate: undefined,\n            headerRowTemplate: undefined,\n            jqueryUITheme: false,\n            jqueryUIDraggable: false,\n            plugins: [],\n            keepLastSelected: true,\n            groups: [],\n            showGroupPanel: false,\n            enableRowReordering: false,\n            showColumnMenu: true,\n            showFilter: true,\n            disableTextSelection: true,\n            filterOptions: {\n                filterText: ko.observable(\"\"),\n                useExternalFilter: false\n            },\n            //Paging\n            enablePaging: false,\n            pagingOptions: {\n                pageSizes: ko.observableArray([250, 500, 1000]), //page Sizes\n                pageSize: ko.observable(250), //Size of Paging data\n                totalServerItems: ko.observable(0), //how many items are on the server (for paging)\n                currentPage: ko.observable(1) //what page they are currently on\n            }\n        },\n        self = this;\n\n    self.maxCanvasHt = ko.observable(0);\n    //self vars\n    self.config = $.extend(defaults, options);\n    self.config.columnDefs = ko.utils.unwrapObservable(options.columnDefs);\n    self.gridId = \"ng\" + window.kg.utils.newId();\n    self.$root = null; //this is the root element that is passed in with the binding handler\n\tself.$groupPanel = null;\n    self.$topPanel = null;\n    self.$headerContainer = null;\n    self.$headerScroller = null;\n    self.$headers = null;\n    self.$viewport = null;\n    self.$canvas = null;\n    self.rootDim = self.config.gridDim;\n    self.sortInfo = ko.isObservable(self.config.sortInfo) ? self.config.sortInfo : ko.observable(self.config.sortInfo);\n    self.sortedData = self.config.data;\n    self.lateBindColumns = false;\n    self.filteredData = ko.observableArray([]);\n    self.lastSortedColumn = undefined;\n    self.showFilter = self.config.showFilter;\n    self.filterText = self.config.filterOptions.filterText;\n    self.disableTextSelection = ko.observable(self.config.disableTextSelection);\n    self.calcMaxCanvasHeight = function() {\n        return (self.configGroups().length > 0) ? (self.rowFactory.parsedData.filter(function (e) {\n            return e[KG_HIDDEN] === false;\n        }).length * self.config.rowHeight) : (self.filteredData().length * self.config.rowHeight);\n    };\n    self.elementDims = {\n        scrollW: 0,\n        scrollH: 0,\n        rowIndexCellW: 25,\n        rowSelectedCellW: 25,\n        rootMaxW: 0,\n        rootMaxH: 0\n    };\n    //self funcs\n    self.setRenderedRows = function (newRows) {\n        self.renderedRows(newRows);\n        self.refreshDomSizes();\n    };\n    self.minRowsToRender = function () {\n        var viewportH = self.viewportDimHeight() || 1;\n        return Math.floor(viewportH / self.config.rowHeight);\n    };\n    self.refreshDomSizes = function () {\n        self.rootDim.outerWidth(self.elementDims.rootMaxW);\n        self.rootDim.outerHeight(self.elementDims.rootMaxH);\n        self.maxCanvasHt(self.calcMaxCanvasHeight());\n    };\n    self.buildColumnDefsFromData = function () {\n        var sd = self.sortedData();\n        if (!self.config.columnDefs) {\n            self.config.columnDefs = [];\n        }\n        if (!sd || !sd[0]) {\n            self.lateBoundColumns = true;\n            return;\n        }\n        var item;\n        item = sd[0];\n\n        window.kg.utils.forIn(item, function (prop, propName) {\n            if (propName != SELECTED_PROP) {\n                self.config.columnDefs.push({\n                    field: propName\n                });\n            }\n        });\n    };\n    self.buildColumns = function () {\n        var columnDefs = self.config.columnDefs,\n            cols = [];\n\n        if (!columnDefs) {\n            self.buildColumnDefsFromData();\n            columnDefs = self.config.columnDefs;\n        }\n        if (self.config.displaySelectionCheckbox && self.config.canSelectRows) {\n            columnDefs.splice(0, 0, {\n                field: '\\u2714',\n                width: self.elementDims.rowSelectedCellW,\n                sortable: false,\n                resizable: false,\n                headerCellTemplate: '<input class=\"kgSelectionHeader\" type=\"checkbox\" data-bind=\"visible: $grid.multiSelect, checked: $grid.allSelected\"/>',\n                cellTemplate: '<div class=\"kgSelectionCell\"><input class=\"kgSelectionCheckbox\" type=\"checkbox\" data-bind=\"checked: $parent.selected\" /></div>'\n            });\n        }\n        if (columnDefs.length > 0) {\n            $.each(columnDefs, function (i, colDef) {\n                var column = new window.kg.Column({\n                    colDef: colDef,\n                    index: i,\n                    headerRowHeight: self.config.headerRowHeight,\n                    sortCallback: self.sortData,\n                    resizeOnDataCallback: self.resizeOnData,\n                    enableResize: self.config.enableColumnResize,\n                    enableSort: self.config.enableSorting\n                }, self);\n                cols.push(column);\n                var indx = self.config.groups.indexOf(colDef.field);\n                if (indx != -1) {\n                    self.configGroups.splice(indx, 0, column);\n                }\n            });\n            self.columns(cols);\n        }\n    };\n    self.configureColumnWidths = function() {\n        var cols = self.config.columnDefs;\n        var numOfCols = cols.length,\n            asterisksArray = [],\n            percentArray = [],\n            asteriskNum = 0,\n            totalWidth = 0;\n        var columns = self.columns();\n        $.each(cols, function (i, col) {\n            var isPercent = false, t = undefined;\n            //if width is not defined, set it to a single star\n            if (window.kg.utils.isNullOrUndefined(col.width)) {\n                col.width = \"*\";\n            } else { // get column width\n                isPercent = isNaN(col.width) ? window.kg.utils.endsWith(col.width, \"%\") : false;\n                t = isPercent ? col.width : parseInt(col.width, 10);\n            }\n            // check if it is a number\n            if (isNaN(t)) {\n                t = col.width;\n                // figure out if the width is defined or if we need to calculate it\n                if (t == 'auto') { // set it for now until we have data and subscribe when it changes so we can set the width.\n                    columns[i].width = columns[i].minWidth;\n                    var temp = columns[i];\n                    $(document).ready(function() { self.resizeOnData(temp, true); });\n                    return;\n                } else if (t.indexOf(\"*\") != -1) {\n                        asteriskNum += t.length;\n                        col.index = i;\n                        asterisksArray.push(col);\n                        return;\n                } else if (isPercent) { // If the width is a percentage, save it until the very last.\n                    col.index = i;\n                    percentArray.push(col);\n                    return;\n                } else { // we can't parse the width so lets throw an error.\n                    throw \"unable to parse column width, use percentage (\\\"10%\\\",\\\"20%\\\", etc...) or \\\"*\\\" to use remaining width of grid\";\n                }\n            } else {\n                totalWidth += columns[i].width = parseInt(col.width, 10);\n            }\n        });\n        // check if we saved any asterisk columns for calculating later\n        if (asterisksArray.length > 0) {\n            self.config.maintainColumnRatios === false ? $.noop() : self.config.maintainColumnRatios = true;\n            // get the remaining width\n            var remainingWidth = self.rootDim.outerWidth() - totalWidth;\n            // calculate the weight of each asterisk rounded down\n            var asteriskVal = Math.floor(remainingWidth / asteriskNum);\n            // set the width of each column based on the number of stars\n            $.each(asterisksArray, function (i, col) {\n\t\t\t\tvar t = col.width.length;\n                columns[col.index].width = asteriskVal * t;\n                //check if we are on the last column\n                if (col.index + 1 == numOfCols) {\n                    var offset = 2; //We're going to remove 2 px so we won't overlflow the viwport by default\n                    // are we overflowing?\n                    if (self.maxCanvasHt() > self.viewportDimHeight()) {\n                        //compensate for scrollbar\n                        offset += window.kg.domUtilityService.ScrollW;\n                    }\n                    columns[col.index].width -= offset;\n                }\n                totalWidth += columns[col.index].width;\n            });\n        }\n        // Now we check if we saved any percentage columns for calculating last\n        if (percentArray.length > 0) {\n            // do the math\n            $.each(percentArray, function (i, col) {\n                var t = col.width;\n                columns[col.index].width = Math.floor(self.rootDim.outerWidth() * (parseInt(t.slice(0, -1), 10) / 100));\n            });\n        }\n        self.columns(columns);\n        window.kg.domUtilityService.BuildStyles(self);\n    };\n    self.init = function () {\n        //factories and services\n        self.selectionService = new window.kg.SelectionService(self);\n        self.rowFactory = new window.kg.RowFactory(self);\n        self.selectionService.Initialize(self.rowFactory);\n        self.searchProvider = new window.kg.SearchProvider(self);\n        self.styleProvider = new window.kg.StyleProvider(self);\n        self.buildColumns();\n        window.kg.sortService.columns = self.columns;\n        self.configGroups.subscribe(function (a) {\n            if (!a) {\n                return;\n            }\n            var tempArr = [];\n            $.each(a, function (i, item) {\n\t\t\t\tif(item){\n\t\t\t\t\ttempArr.push(item.field || item);\n\t\t\t\t}\n            });\n            self.config.groups = tempArr;\n            self.rowFactory.filteredDataChanged();\n        });\n        self.filteredData.subscribe(function () {\n            if (self.$$selectionPhase) {\n                return;\n            }\n\t\t\tself.maxCanvasHt(self.calcMaxCanvasHeight());\n\t\t\tif (!self.isSorting) {\n\t\t\t    self.configureColumnWidths();\n\t\t\t}\n\t\t});\n        self.maxCanvasHt(self.calcMaxCanvasHeight());\n        self.searchProvider.evalFilter();\n        self.refreshDomSizes();\n    };\n    self.prevScrollTop = 0;\n    self.prevScrollIndex = 0;\n    self.adjustScrollTop = function (scrollTop, force) {\n        if (self.prevScrollTop === scrollTop && !force) { return; }\n        var rowIndex = Math.floor(scrollTop / self.config.rowHeight);\n        // Have we hit the threshold going down?\n        if (self.prevScrollTop < scrollTop && rowIndex < self.prevScrollIndex + SCROLL_THRESHOLD) {\n            return;\n        }\n        //Have we hit the threshold going up?\n        if (self.prevScrollTop > scrollTop && rowIndex > self.prevScrollIndex - SCROLL_THRESHOLD) {\n            return;\n        }\n        self.prevScrollTop = scrollTop;\n        self.rowFactory.UpdateViewableRange(new window.kg.Range(Math.max(0, rowIndex - EXCESS_ROWS), rowIndex + self.minRowsToRender() + EXCESS_ROWS));\n        self.prevScrollIndex = rowIndex;\n    };\n    self.adjustScrollLeft = function (scrollLeft) {\n        if (self.$headerContainer) {\n            self.$headerContainer.scrollLeft(scrollLeft);\n        }\n    };\n    self.resizeOnData = function (col) {\n        // we calculate the longest data.\n        var longest = col.minWidth;\n        var arr = window.kg.utils.getElementsByClassName('col' + col.index);\n        $.each(arr, function (index, elem) {\n            var i;\n            if (index === 0) {\n                var kgHeaderText = $(elem).find('.kgHeaderText');\n                i = window.kg.utils.visualLength(kgHeaderText) + 10;// +10 some margin\n            } else {\n                var ngCellText = $(elem).find('.kgCellText');\n                i = window.kg.utils.visualLength(ngCellText) + 10; // +10 some margin\n            }\n            if (i > longest) {\n                longest = i;\n            }\n        });\n        col.width = longest = Math.min(col.maxWidth, longest + 7); // + 7 px to make it look decent.\n        window.kg.domUtilityService.BuildStyles(self);\n    };\n    self.sortData = function (col, direction) {\n        // if external sorting is being used, do nothing.\n        self.isSorting = true;\n        self.sortInfo({\n            column: col,\n            direction: direction\n        });\n        self.clearSortingData(col);\n        if(!self.config.useExternalSorting){\n            window.kg.sortService.Sort(self.sortInfo.peek(), self.sortedData);\n        } else {\n            self.config.sortInfo(self.sortInfo.peek());\n        }\n        self.lastSortedColumn = col;\n        self.isSorting = false;\n    };\n    self.clearSortingData = function (col) {\n        if (!col) {\n            $.each(self.columns(), function (i, c) {\n                c.sortDirection(\"\");\n            });\n        } else if (self.lastSortedColumn && col != self.lastSortedColumn) {\n            self.lastSortedColumn.sortDirection(\"\");\n        }\n    };\n    self.fixColumnIndexes = function () {\n        self.$$indexPhase = true;\n        //fix column indexes\n        var cols = self.columns.peek();\n        $.each(cols, function (i, col) {\n            col.index = i;\n        });\n        self.$$indexPhase = false;\n    };\n    //self vars\n    self.elementsNeedMeasuring = true;\n    self.columns = ko.observableArray([]);\n    self.columns.subscribe(function(newCols) {\n        self.config.columnsChanged(newCols);\n    });\n    self.renderedRows = ko.observableArray([]);\n    self.headerRow = null;\n    self.rowHeight = self.config.rowHeight;\n\tself.jqueryUITheme = ko.observable(self.config.jqueryUITheme);\n    self.footer = null;\n    self.selectedItems = self.config.selectedItems;\n    self.multiSelect = self.config.multiSelect;\n    self.footerVisible = window.kg.utils.isNullOrUndefined(self.config.displayFooter) ? self.config.footerVisible : self.config.displayFooter;\n    self.config.footerRowHeight = self.footerVisible ? self.config.footerRowHeight : 0;\n\tself.showColumnMenu = self.config.showColumnMenu;\n    self.showMenu = ko.observable(false);\n    self.configGroups = ko.observableArray([]);\n\n    //Paging\n    self.enablePaging = self.config.enablePaging;\n    self.pagingOptions = self.config.pagingOptions;\n    //Templates\n    self.rowTemplate = self.config.rowTemplate || window.kg.defaultRowTemplate();\n    self.headerRowTemplate = self.config.headerRowTemplate || window.kg.defaultHeaderRowTemplate();\n    if (self.config.rowTemplate && !TEMPLATE_REGEXP.test(self.config.rowTemplate)) {\n        self.rowTemplate = window.kg.utils.getTemplatePromise(self.config.rowTemplate);\n    }\n    if (self.config.headerRowTemplate && !TEMPLATE_REGEXP.test(self.config.headerRowTemplate)) {\n        self.headerRowTemplate = window.kg.utils.getTemplatePromise(self.config.headerRowTemplate);\n    }\n    //scope funcs\n    self.visibleColumns = ko.computed(function () {\n        var cols = self.columns();\n        return cols.filter(function (col) {\n            var isVis = col.visible();\n            return isVis;\n        });\n    });\n    self.nonAggColumns = ko.computed(function () {\n        return self.columns().filter(function (col) {\n            return !col.isAggCol;\n        });\n    });\n    self.toggleShowMenu = function () {\n        self.showMenu(!self.showMenu());\n    };\n    self.allSelected = self.config.selectAllState;\n    self.allSelected.subscribe(function (state) {\n        if (self.config.beforeSelectionChange(self.sortedData.peek(), this)) {\n            self.selectionService.toggleSelectAll(state);\n            self.config.afterSelectionChange(self.selectedItems.peek(), this);\n        }\n    });\n    self.totalFilteredItemsLength = ko.computed(function () {\n        return self.filteredData().length;\n    });\n\tself.showGroupPanel = ko.computed(function(){\n\t\treturn self.config.showGroupPanel;\n\t});\n\tself.topPanelHeight = ko.observable(self.config.showGroupPanel === true ? (self.config.headerRowHeight * 2) : self.config.headerRowHeight);\n\tself.viewportDimHeight = ko.computed(function () {\n        return Math.max(0, self.rootDim.outerHeight() - self.topPanelHeight() - self.config.footerRowHeight - 2);\n    });\n\tself.groupBy = function (col) {\n\t    if (self.sortedData().length < 1) {\n\t        return;\n\t    }\n        var indx = self.configGroups().indexOf(col);\n        if (indx == -1) {\n\t\t\tcol.isGroupedBy(true);\n            self.configGroups.push(col);\n\t\t\tcol.groupIndex(self.configGroups().length);\n        } else {\n\t\t\tself.removeGroup(indx);\n        }\n        window.kg.domUtilityService.BuildStyles(self);\n    };\n    self.removeGroup = function(index) {\n\t\tvar col = self.columns().filter(function(item){\n\t\t\treturn item.groupIndex() == (index + 1);\n\t\t})[0];\n\t\tcol.isGroupedBy(false);\n\t\tcol.groupIndex(0);\n        self.columns.splice(index, 1);\n        self.configGroups.splice(index, 1);\n\t\tself.fixGroupIndexes();\n        if (self.configGroups().length === 0) {\n            self.fixColumnIndexes();\n        }\n        window.kg.domUtilityService.BuildStyles(self);\n    };\n\tself.fixGroupIndexes = function(){\n\t\t$.each(self.configGroups(), function(i,item){\n\t\t\titem.groupIndex(i + 1);\n\t\t});\n\t};\n    self.totalRowWidth = function () {\n        var totalWidth = 0,\n            cols = self.visibleColumns();\n        $.each(cols, function (i, col) {\n            totalWidth += col.width;\n        });\n        return totalWidth;\n    };\n    self.headerScrollerDim = function () {\n        var viewportH = self.viewportDimHeight(),\n            maxHeight = self.maxCanvasHt(),\n            vScrollBarIsOpen = (maxHeight > viewportH),\n            newDim = new window.kg.Dimension();\n\n        newDim.autoFitHeight = true;\n        newDim.outerWidth = self.totalRowWidth();\n        if (vScrollBarIsOpen) { newDim.outerWidth += self.elementDims.scrollW; }\n        else if ((maxHeight - viewportH) <= self.elementDims.scrollH) { //if the horizontal scroll is open it forces the viewport to be smaller\n            newDim.outerWidth += self.elementDims.scrollW;\n        }\n        return newDim;\n    };\n    //footer\n    self.jqueryUITheme = self.config.jqueryUITheme;\n    self.maxRows = ko.observable(Math.max(self.config.pagingOptions.totalServerItems() || self.sortedData().length, 1));\n    self.maxRowsDisplay = ko.computed(function () {\n        return self.maxRows();\n    });\n    self.multiSelect = ko.observable((self.config.canSelectRows && self.config.multiSelect));\n    self.selectedItemCount = ko.computed(function () {\n        return self.selectedItems().length;\n    });\n    self.maxPages = ko.computed(function () {\n        self.maxRows(Math.max(self.config.pagingOptions.totalServerItems() || self.sortedData().length, 1));\n        return Math.ceil(self.maxRows() / self.pagingOptions.pageSize());\n    });\n    self.pageForward = function () {\n        var page = self.config.pagingOptions.currentPage();\n        self.config.pagingOptions.currentPage(Math.min(page + 1, self.maxPages()));\n    };\n    self.pageBackward = function () {\n        var page = self.config.pagingOptions.currentPage();\n        self.config.pagingOptions.currentPage(Math.max(page - 1, 1));\n    };\n    self.pageToFirst = function () {\n        self.config.pagingOptions.currentPage(1);\n    };\n    self.pageToLast = function () {\n        var maxPages = self.maxPages();\n        self.config.pagingOptions.currentPage(maxPages);\n    };\n    self.cantPageForward = ko.computed(function () {\n        var curPage = self.config.pagingOptions.currentPage();\n        var maxPages = self.maxPages();\n        return !(curPage < maxPages);\n    });\n    self.cantPageBackward = ko.computed(function () {\n        var curPage = self.config.pagingOptions.currentPage();\n        return !(curPage > 1);\n    });\n    //call init\n    self.init();\n};\n\nkg.Range = function (top, bottom) {\n    this.topRow = top;\n    this.bottomRow = bottom;\n};\nwindow.kg.Row = function (entity, config, selectionService) {\n    var self = this; // constant for the selection property that we add to each data item\n\n    self.canSelectRows = config.canSelectRows;\n\n    self.rowClasses = config.rowClasses;\n    self.selectedItems = config.selectedItems;\n    self.entity = entity;\n    self.selectionService = selectionService;\n\n    self.selected = ko.observable(false);\n    self.continueSelection = function(event) {\n        self.selectionService.ChangeSelection(self, event);\n    };\n    self.toggleSelected = function (row, event) {\n        if (!self.canSelectRows) {\n            return true;\n        }\n        var element = event.target || event;\n        //check and make sure its not the bubbling up of our checked 'click' event\n        if (element.type == \"checkbox\") {\n            self.selected(!self.selected());\n        }\n        if (config.selectWithCheckboxOnly && element.type != \"checkbox\"){\n            return true;\n        } else {\n            if (self.beforeSelectionChange(self, event)) {\n                self.continueSelection(event);\n                return self.afterSelectionChange(self, event);\n            }\n        }\n        return false;\n    };\n    //selectify the entity\n    if (self.entity[SELECTED_PROP] === undefined) {\n        self.entity[SELECTED_PROP] = false;\n    } else {\n        // or else maintain the selection set by the entity.\n        self.selectionService.setSelection(self, self.entity[SELECTED_PROP]);\n    }\n    self.rowIndex = ko.observable(0);\n    self.offsetTop = ko.observable(\"0px\");\n    self.rowDisplayIndex = 0;\n    self.isEven = ko.computed(function () {\n        if (self.rowIndex() % 2 === 0) {\n            return true;\n        }\n        return false;\n    });\n    self.isOdd = ko.computed(function () {\n        if (self.rowIndex() % 2 !== 0) {\n            return true;\n        }\n        return false;\n    });\n    self.beforeSelectionChange = config.beforeSelectionChangeCallback;\n    self.afterSelectionChange = config.afterSelectionChangeCallback;\n    self.propertyCache = {};\n    self.getProperty = function (path) {\n        return self.propertyCache[path] || (self.propertyCache[path] = window.kg.utils.evalProperty(self.entity, path));\n    };\n};\n\nwindow.kg.RowFactory = function (grid) {\n    var self = this;\n    // we cache rows when they are built, and then blow the cache away when sorting\n    self.rowCache = [];\n    self.aggCache = {};\n    self.parentCache = []; // Used for grouping and is cleared each time groups are calulated.\n    self.dataChanged = true;\n    self.parsedData = [];\n    self.rowConfig = {};\n    self.selectionService = grid.selectionService;\n    self.rowHeight = 30;\n    self.numberOfAggregates = 0;\n    self.groupedData = undefined;\n    self.rowHeight = grid.config.rowHeight;\n    self.rowConfig = {\n        canSelectRows: grid.config.canSelectRows,\n        rowClasses: grid.config.rowClasses,\n        selectedItems: grid.config.selectedItems,\n        selectWithCheckboxOnly: grid.config.selectWithCheckboxOnly,\n        beforeSelectionChangeCallback: grid.config.beforeSelectionChange,\n        afterSelectionChangeCallback: grid.config.afterSelectionChange\n    };\n\n    self.renderedRange = new window.kg.Range(0, grid.minRowsToRender() + EXCESS_ROWS);\n    // Builds rows for each data item in the 'filteredData'\n    // @entity - the data item\n    // @rowIndex - the index of the row\n    self.buildEntityRow = function(entity, rowIndex) {\n        var row = self.rowCache[rowIndex]; // first check to see if we've already built it\n        if (!row) {\n            // build the row\n            row = new window.kg.Row(entity, self.rowConfig, self.selectionService);\n            row.rowIndex(rowIndex + 1); //not a zero-based rowIndex\n            row.offsetTop((self.rowHeight * rowIndex).toString() + 'px');\n            row.selected(entity[SELECTED_PROP]);\n            // finally cache it for the next round\n            self.rowCache[rowIndex] = row;\n        }\n        return row;\n    };\n\n    self.buildAggregateRow = function(aggEntity, rowIndex) {\n        var agg = self.aggCache[aggEntity.aggIndex]; // first check to see if we've already built it\n        if (!agg) {\n            // build the row\n            agg = new window.kg.Aggregate(aggEntity, self);\n            self.aggCache[aggEntity.aggIndex] = agg;\n        }\n        agg.index = rowIndex + 1; //not a zero-based rowIndex\n        agg.offsetTop((self.rowHeight * rowIndex).toString() + 'px');\n        return agg;\n    };\n    self.UpdateViewableRange = function(newRange) {\n        self.renderedRange = newRange;\n        self.renderedChange();\n    };\n    self.filteredDataChanged = function() {\n        // check for latebound autogenerated columns\n        if (grid.lateBoundColumns && grid.filteredData().length > 1) {\n            grid.config.columnDefs = undefined;\n            grid.buildColumns();\n            grid.lateBoundColumns = false;\n        }\n        self.dataChanged = true;\n        self.rowCache = []; //if data source changes, kill this!\n        if (grid.config.groups.length > 0) {\n            self.getGrouping(grid.config.groups);\n        }\n        self.UpdateViewableRange(self.renderedRange);\n    };\n\n    self.renderedChange = function() {\n        if (!self.groupedData || grid.config.groups.length < 1) {\n            self.renderedChangeNoGroups();\n            grid.refreshDomSizes();\n            return;\n        }\n        self.parentCache = [];\n        var rowArr = [];\n        var dataArray = self.parsedData.filter(function(e) {\n            return e[KG_HIDDEN] === false;\n        }).slice(self.renderedRange.topRow, self.renderedRange.bottomRow);\n        $.each(dataArray, function (indx, item) {\n            var row;\n            if (item.isAggRow) {\n                row = self.buildAggregateRow(item, self.renderedRange.topRow + indx);\n            } else {\n                row = self.buildEntityRow(item, self.renderedRange.topRow + indx);\n            }\n            //add the row to our return array\n            rowArr.push(row);\n        });\n        grid.setRenderedRows(rowArr);\n        grid.refreshDomSizes();\n    };\n\n    self.renderedChangeNoGroups = function() {\n        var rowArr = [];\n        var dataArr = grid.filteredData.slice(self.renderedRange.topRow, self.renderedRange.bottomRow);\n        $.each(dataArr, function (i, item) {\n            var row = self.buildEntityRow(item, self.renderedRange.topRow + i);\n            //add the row to our return array\n            rowArr.push(row);\n        });\n        grid.setRenderedRows(rowArr);\n    };\n\n    //magical recursion. it works. I swear it. I figured it out in the shower one day.\n    self.parseGroupData = function(g) {\n        if (g.values) {\n            $.each(g.values, function (i, item) {\n                // get the last parent in the array because that's where our children want to be\n                self.parentCache[self.parentCache.length - 1].children.push(item);\n                //add the row to our return array\n                self.parsedData.push(item);\n            });\n        } else {\n            for (var prop in g) {\n                // exclude the meta properties.\n                if (prop == KG_FIELD || prop == KG_DEPTH || prop == KG_COLUMN) {\n                    continue;\n                } else if (g.hasOwnProperty(prop)) {\n                    //build the aggregate row\n                    var agg = self.buildAggregateRow({\n                        gField: g[KG_FIELD],\n                        gLabel: prop,\n                        gDepth: g[KG_DEPTH],\n                        isAggRow: true,\n                        '_kg_hidden_': false,\n                        children: [],\n                        aggChildren: [],\n                        aggIndex: self.numberOfAggregates,\n                        aggLabelFilter: g[KG_COLUMN].aggLabelFilter\n                    }, 0);\n                    self.numberOfAggregates++;\n                    //set the aggregate parent to the parent in the array that is one less deep.\n                    agg.parent = self.parentCache[agg.depth - 1];\n                    // if we have a parent, set the parent to not be collapsed and append the current agg to its children\n                    if (agg.parent) {\n                        agg.parent.collapsed(false);\n                        agg.parent.aggChildren.push(agg);\n                    }\n                    // add the aggregate row to the parsed data.\n                    self.parsedData.push(agg.entity);\n                    // the current aggregate now the parent of the current depth\n                    self.parentCache[agg.depth] = agg;\n                    // dig deeper for more aggregates or children.\n                    self.parseGroupData(g[prop]);\n                }\n            }\n        }\n    };\n    //Shuffle the data into their respective groupings.\n    self.getGrouping = function(groups) {\n        self.aggCache = [];\n        self.rowCache = [];\n        self.numberOfAggregates = 0;\n        self.groupedData = {};\n        // Here we set the onmousedown event handler to the header container.\n        var data = grid.filteredData();\n        var maxDepth = groups.length;\n        var cols = grid.columns();\n\n        $.each(data, function (i, item) {\n            item[KG_HIDDEN] = true;\n            var ptr = self.groupedData;\n            $.each(groups, function(depth, group) {\n                if (!cols[depth].isAggCol && depth <= maxDepth) {\n                    grid.columns.splice(item.gDepth, 0, new window.kg.Column({\n                        colDef: {\n                            field: '',\n                            width: 25,\n                            sortable: false,\n                            resizable: false,\n                            headerCellTemplate: '<div class=\"kgAggHeader\"></div>'\n                        },\n                        isAggCol: true,\n                        index: item.gDepth,\n                        headerRowHeight: grid.config.headerRowHeight\n                    }));\n                    window.kg.domUtilityService.BuildStyles(grid);\n                }\n                var col = cols.filter(function (c) { return c.field == group; })[0];\n                var val = window.kg.utils.evalProperty(item, group);\n                if (col.cellFilter) {\n                    val = col.cellFilter(val);\n                }\n                val = val ? val.toString() : 'null';\n                if (!ptr[val]) {\n                    ptr[val] = {};\n                }\n                if (!ptr[KG_FIELD]) {\n                    ptr[KG_FIELD] = group;\n                }\n                if (!ptr[KG_DEPTH]) {\n                    ptr[KG_DEPTH] = depth;\n                }\n                if (!ptr[KG_COLUMN]) {\n                    ptr[KG_COLUMN] = col;\n                }\n                ptr = ptr[val];\n            });\n            if (!ptr.values) {\n                ptr.values = [];\n            }\n            ptr.values.push(item);\n        });\n        grid.fixColumnIndexes();\n        self.parsedData.length = 0;\n        self.parseGroupData(self.groupedData);\n    };\n\n    if (grid.config.groups.length > 0 && grid.filteredData().length > 0) {\n        self.getGrouping(grid.config.groups);\n    }\n};\n\nwindow.kg.SearchProvider = function (grid) {\n    var self = this,\n        searchConditions = [],\n        lastSearchStr;\n    self.extFilter = grid.config.filterOptions.useExternalFilter;\n    self.showFilter = grid.config.showFilter;\n    self.filterText = grid.config.filterOptions.filterText;\n    self.throttle = grid.config.filterOptions.filterThrottle;\n    self.fieldMap = {};\n    self.evalFilter = function () {\n        if (searchConditions.length === 0) {\n            grid.filteredData(grid.sortedData.peek().filter(function(item) {\n                return !item._destroy;\n            }));\n        } else {\n            grid.filteredData(grid.sortedData.peek().filter(function(item) {\n                if (item._destroy) {\n                    return false;\n                }\n\n                for (var i = 0, len = searchConditions.length; i < len; i++) {\n                    var condition = searchConditions[i];\n                    //Search entire row\n                    if (!condition.column) {\n                        for (var prop in item) {\n                            if (item.hasOwnProperty(prop)) {\n                                var pVal = ko.utils.unwrapObservable(item[prop]);\n                                if (pVal && condition.regex.test(pVal.toString())) {\n                                    return true;\n                                }\n                            }\n                        }\n                        return false;\n                    }\n                    //Search by column.\n                    var field = ko.utils.unwrapObservable(item[condition.column]) || ko.utils.unwrapObservable(item[self.fieldMap[condition.columnDisplay]]);\n                    if (!field || !condition.regex.test(field.toString())) {\n                        return false;\n                    }\n                }\n                return true;\n            }));\n        }\n        grid.rowFactory.filteredDataChanged();\n    };\n    var getRegExp = function(str, modifiers) {\n        try {\n            return new RegExp(str, modifiers);\n        } catch(err) {\n            //Escape all RegExp metacharacters.\n            return new RegExp(str.replace(/(\\^|\\$|\\(|\\)|\\<|\\>|\\[|\\]|\\{|\\}|\\\\|\\||\\.|\\*|\\+|\\?)/g, '\\\\$1'));\n        }\n    };\n    var buildSearchConditions = function (a) {\n        //reset.\n        searchConditions = [];\n        var qStr;\n        if (!(qStr = $.trim(a))) {\n            return;\n        }\n        var columnFilters = qStr.split(\";\");\n        $.each(columnFilters, function (i, filter) {\n            var args = filter.split(':');\n            if (args.length > 1) {\n                var columnName = $.trim(args[0]);\n                var columnValue = $.trim(args[1]);\n                if (columnName && columnValue) {\n                    searchConditions.push({\n                        column: columnName,\n                        columnDisplay: columnName.replace(/\\s+/g, '').toLowerCase(),\n                        regex: getRegExp(columnValue, 'i')\n                    });\n                }\n            } else {\n                var val = $.trim(args[0]);\n                if (val) {\n                    searchConditions.push({\n                        column: '',\n                        regex: getRegExp(val, 'i')\n                    });\n                }\n            }\n        });\n    };\n\n    var filterTextComputed = ko.computed(function () {\n        var a = self.filterText();\n        if (!self.extFilter && a != lastSearchStr) {\n            //To prevent circular dependency when throttle is enabled.\n            lastSearchStr = a;\n            buildSearchConditions(a);\n            self.evalFilter();\n        }\n    });\n    if (typeof self.throttle === 'number') {\n        filterTextComputed.extend({ throttle: self.throttle });\n    }\n    if (!self.extFilter) {\n        grid.columns.subscribe(function (a) {\n            $.each(a, function (i, col) {\n                self.fieldMap[col.displayName().toLowerCase().replace(/\\s+/g, '')] = col.field;\n            });\n        });\n    }\n};\n\nwindow.kg.SelectionService = function (grid) {\n    var self = this;\n    self.multi = grid.config.multiSelect;\n    self.selectedItems = grid.config.selectedItems;\n    self.selectedIndex = grid.config.selectedIndex;\n    self.lastClickedRow = undefined;\n    self.ignoreSelectedItemChanges = false; // flag to prevent circular event loops keeping single-select var in sync\n\n    self.rowFactory = {};\n\tself.Initialize = function (rowFactory) {\n        self.rowFactory = rowFactory;\n    };\n\t\t\n\t// function to manage the selection action of a data item (entity)\n\tself.ChangeSelection = function (rowItem, evt) {\n\t    grid.$$selectionPhase = true;\n\t    if (evt && evt.shiftKey && self.multi) {\n\t        if (self.lastClickedRow) {\n\t            var thisIndx = grid.filteredData.indexOf(rowItem.entity);\n\t            var prevIndx = grid.filteredData.indexOf(self.lastClickedRow.entity);\n\t            if (thisIndx == prevIndx) {\n\t                return false;\n\t            }\n\t            prevIndx++;\n\t            if (thisIndx < prevIndx) {\n\t                thisIndx = thisIndx ^ prevIndx;\n\t                prevIndx = thisIndx ^ prevIndx;\n\t                thisIndx = thisIndx ^ prevIndx;\n\t            }\n\t            var rows = [];\n\t            for (; prevIndx <= thisIndx; prevIndx++) {\n\t                rows.push(self.rowFactory.rowCache[prevIndx]);\n\t            }\n\t            if (rows[rows.length - 1].beforeSelectionChange(rows, evt)) {\n\t                $.each(rows, function(i, ri) {\n\t                    ri.selected(true);\n\t                    ri.entity[SELECTED_PROP] = true;\n\t                    if (self.selectedItems.indexOf(ri.entity) === -1) {\n\t                        self.selectedItems.push(ri.entity);\n\t                    }\n\t                });\n\t                rows[rows.length - 1].afterSelectionChange(rows, evt);\n\t            }\n\t            self.lastClickedRow = rows[rows.length - 1];\n\t            return true;\n\t        }\n\t    } else if (!self.multi) {\n\t        if (self.lastClickedRow && self.lastClickedRow != rowItem) {\n\t            self.setSelection(self.lastClickedRow, false);\n\t        }\n\t        self.setSelection(rowItem, grid.config.keepLastSelected ? true : !rowItem.selected());\n\t    } else {\n\t        self.setSelection(rowItem, !rowItem.selected());\n\t    }\n\t    self.lastClickedRow = rowItem;\n\t    grid.$$selectionPhase = false;\n        return true;\n    };\n\n    // just call this func and hand it the rowItem you want to select (or de-select)    \n    self.setSelection = function(rowItem, isSelected) {\n        rowItem.selected(isSelected) ;\n        rowItem.entity[SELECTED_PROP] = isSelected;\n        if (!isSelected) {\n            var indx = self.selectedItems.indexOf(rowItem.entity);\n            self.selectedItems.splice(indx, 1);\n        } else {\n            if (self.selectedItems.indexOf(rowItem.entity) === -1) {\n                self.selectedItems.push(rowItem.entity);\n            }\n        }\n    };\n    \n    // @return - boolean indicating if all items are selected or not\n    // @val - boolean indicating whether to select all/de-select all\n    self.toggleSelectAll = function (checkAll) {\n        var selectedlength = self.selectedItems().length;\n        if (selectedlength > 0) {\n            self.selectedItems.splice(0, selectedlength);\n        }\n        $.each(grid.filteredData(), function (i, item) {\n            item[SELECTED_PROP] = checkAll;\n            if (checkAll) {\n                self.selectedItems.push(item);\n            }\n        });\n        $.each(self.rowFactory.rowCache, function (i, row) {\n            if (row && row.selected) {\n                row.selected(checkAll);\n            }\n        });\n    };\n};\nwindow.kg.sortService = {\n    colSortFnCache: {}, // cache of sorting functions. Once we create them, we don't want to keep re-doing it\n    dateRE: /^(\\d\\d?)[\\/\\.-](\\d\\d?)[\\/\\.-]((\\d\\d)?\\d\\d)$/, // nasty regex for date parsing\n    guessSortFn: function(item) {\n        var sortFn, // sorting function that is guessed\n            itemType, // the typeof item\n            dateParts, // for date parsing\n            month, // for date parsing\n            day; // for date parsing\n\n        if (item === undefined || item === null || item === '') {\n            return null;\n        }\n        itemType = typeof(item);\n        //check for numbers and booleans\n        switch (itemType) {\n            case \"number\":\n                sortFn = window.kg.sortService.sortNumber;\n                break;\n            case \"boolean\":\n                sortFn = window.kg.sortService.sortBool;\n                break;\n            default:\n                sortFn = undefined;\n                break;\n        }\n        //if we found one, return it\n        if (sortFn) {\n            return sortFn;\n        }\n        //check if the item is a valid Date\n        if (Object.prototype.toString.call(item) === '[object Date]') {\n            return window.kg.sortService.sortDate;\n        }\n        // if we aren't left with a string, return a basic sorting function...\n        if (itemType !== \"string\") {\n            return window.kg.sortService.basicSort;\n        }\n        // now lets string check..\n        //check if the item data is a valid number\n        if (item.match(/^-?[£$¤]?[\\d,.]+%?$/)) {\n            return window.kg.sortService.sortNumberStr;\n        }\n        // check for a date: dd/mm/yyyy or dd/mm/yy\n        // can have / or . or - as separator\n        // can be mm/dd as well\n        dateParts = item.match(window.kg.sortService.dateRE);\n        if (dateParts) {\n            // looks like a date\n            month = parseInt(dateParts[1], 10);\n            day = parseInt(dateParts[2], 10);\n            if (month > 12) {\n                // definitely dd/mm\n                return window.kg.sortService.sortDDMMStr;\n            } else if (day > 12) {\n                return window.kg.sortService.sortMMDDStr;\n            } else {\n                // looks like a date, but we can't tell which, so assume that it's MM/DD\n                return window.kg.sortService.sortMMDDStr;\n            }\n        }\n        //finally just sort the normal string...\n        return window.kg.sortService.sortAlpha;\n    },\n    basicSort: function(a, b) {\n        if (a == b) {\n            return 0;\n        }\n        if (a < b) {\n            return -1;\n        }\n        return 1;\n    },\n    sortNumber: function(a, b) {\n        return a - b;\n    },\n    sortNumberStr: function(a, b) {\n        var numA,\n            numB,\n            badA = false,\n            badB = false;\n        numA = parseFloat(a.replace(/[^0-9.-]/g, ''));\n        if (isNaN(numA)) {\n            badA = true;\n        }\n        numB = parseFloat(b.replace(/[^0-9.-]/g, ''));\n        if (isNaN(numB)) {\n            badB = true;\n        }\n        // we want bad ones to get pushed to the bottom... which effectively is \"greater than\"\n        if (badA && badB) {\n            return 0;\n        }\n        if (badA) {\n            return 1;\n        }\n        if (badB) {\n            return -1;\n        }\n        return numA - numB;\n    },\n    sortAlpha: function(a, b) {\n        var strA = a.toLowerCase(),\n            strB = b.toLowerCase();\n        return strA == strB ? 0 : (strA < strB ? -1 : 1);\n    },\n    sortBool: function(a, b) {\n        if (a && b) {\n            return 0;\n        }\n        if (!a && !b) {\n            return 0;\n        } else {\n            return a ? 1 : -1;\n        }\n    },\n    sortDate: function(a, b) {\n        var timeA = a.getTime(),\n            timeB = b.getTime();\n        return timeA == timeB ? 0 : (timeA < timeB ? -1 : 1);\n    },\n    sortDDMMStr: function(a, b) {\n        var dateA, dateB, mtch, m, d, y;\n        mtch = a.match(window.kg.sortService.dateRE);\n        y = mtch[3];\n        m = mtch[2];\n        d = mtch[1];\n        if (m.length == 1) {\n            m = '0' + m;\n        }\n        if (d.length == 1) {\n            d = '0' + d;\n        }\n        dateA = y + m + d;\n        mtch = b.match(window.kg.sortService.dateRE);\n        y = mtch[3];\n        m = mtch[2];\n        d = mtch[1];\n        if (m.length == 1) {\n            m = '0' + m;\n        }\n        if (d.length == 1) {\n            d = '0' + d;\n        }\n        dateB = y + m + d;\n        if (dateA == dateB) {\n            return 0;\n        }\n        if (dateA < dateB) {\n            return -1;\n        }\n        return 1;\n    },\n    sortMMDDStr: function(a, b) {\n        var dateA, dateB, mtch, m, d, y;\n        mtch = a.match(window.kg.sortService.dateRE);\n        y = mtch[3];\n        d = mtch[2];\n        m = mtch[1];\n        if (m.length == 1) {\n            m = '0' + m;\n        }\n        if (d.length == 1) {\n            d = '0' + d;\n        }\n        dateA = y + m + d;\n        mtch = b.match(window.kg.sortService.dateRE);\n        y = mtch[3];\n        d = mtch[2];\n        m = mtch[1];\n        if (m.length == 1) {\n            m = '0' + m;\n        }\n        if (d.length == 1) {\n            d = '0' + d;\n        }\n        dateB = y + m + d;\n        if (dateA == dateB) {\n            return 0;\n        }\n        if (dateA < dateB) {\n            return -1;\n        }\n        return 1;\n    },\n    sortData: function (data /*datasource*/, sortInfo) {\n        var unwrappedData = data();\n        // first make sure we are even supposed to do work\n        if (!unwrappedData || !sortInfo) {\n            return;\n        }\n        // grab the metadata for the rest of the logic\n        var col = sortInfo.column,\n            direction = sortInfo.direction,\n            sortFn,\n            item;\n        //see if we already figured out what to use to sort the column\n        if (window.kg.sortService.colSortFnCache[col.field]) {\n            sortFn = window.kg.sortService.colSortFnCache[col.field];\n        } else if (col.sortingAlgorithm != undefined) {\n            sortFn = col.sortingAlgorithm;\n            window.kg.sortService.colSortFnCache[col.field] = col.sortingAlgorithm;\n        } else { // try and guess what sort function to use\n            item = unwrappedData[0];\n            if (!item) {\n                return;\n            }\n            sortFn = kg.sortService.guessSortFn(item[col.field]);\n            //cache it\n            if (sortFn) {\n                window.kg.sortService.colSortFnCache[col.field] = sortFn;\n            } else {\n                // we assign the alpha sort because anything that is null/undefined will never get passed to\n                // the actual sorting function. It will get caught in our null check and returned to be sorted\n                // down to the bottom\n                sortFn = window.kg.sortService.sortAlpha;\n            }\n        }\n        //now actually sort the data\n        unwrappedData.sort(function (itemA, itemB) {\n            var propA = window.kg.utils.evalProperty(itemA, col.field);\n            var propB = window.kg.utils.evalProperty(itemB, col.field);\n            // we want to force nulls and such to the bottom when we sort... which effectively is \"greater than\"\n            if (!propB && !propA) {\n                return 0;\n            } else if (!propA) {\n                return 1;\n            } else if (!propB) {\n                return -1;\n            }\n            //made it this far, we don't have to worry about null & undefined\n            if (direction === ASC) {\n                return sortFn(propA, propB);\n            } else {\n                return 0 - sortFn(propA, propB);\n            }\n        });\n        data(unwrappedData);\n    },\n    Sort: function (sortInfo, data) {\n        if (window.kg.sortService.isSorting) {\n            return;\n        }\n        window.kg.sortService.isSorting = true;\n        window.kg.sortService.sortData(data, sortInfo);\n        window.kg.sortService.isSorting = false;\n    }\n};\n\nwindow.kg.StyleProvider = function (grid) {\n    grid.canvasStyle = ko.computed(function() {\n        return { \"height\": grid.maxCanvasHt().toString() + \"px\" };\n    });\n    grid.headerScrollerStyle = ko.computed(function() {\n        return { \"height\": grid.config.headerRowHeight + \"px\" };\n    });\n    grid.topPanelStyle = ko.computed(function() {\n        return { \"width\": grid.rootDim.outerWidth() + \"px\", \"height\": grid.topPanelHeight() + \"px\" };\n    });\n    grid.headerStyle = ko.computed(function() {\n        return { \"width\": Math.max(0, grid.rootDim.outerWidth() - window.kg.domUtilityService.ScrollW) + \"px\", \"height\": grid.config.headerRowHeight + \"px\" };\n    });\n    grid.viewportStyle = ko.computed(function() {\n        return { \"width\": grid.rootDim.outerWidth() + \"px\", \"height\": grid.viewportDimHeight() + \"px\" };\n    });\n\tgrid.footerStyle = ko.computed(function () {\n        return { \"width\": grid.rootDim.outerWidth() + \"px\", \"height\": grid.config.footerRowHeight + \"px\" };\n    });\n};})(window);"],"sourceRoot":"/source/"}